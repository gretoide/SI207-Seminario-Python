versión 1.0
		
		Guía de estilo de codificación para Seminario C

Este breve documento describe los estilos de codificación de preferencia para la
cátedra de Seminario de lenguaje C. Si bien el estilo de codificación es una
elección muy personal y este documento no pretende forzar un punto de vista
particular, tener un estilo consistente hace más fácil enteder el código que
escribas a vos y a tus ayudantes/correctores. Por favor tenelos en cuenta a la
hora de escribir tus programas.

Existen varías guias como esta y en general cada proyecto particular tiene las
suyas. Esta guía está basada en el "Linux kernel coding style", escrito por Greg
Kroah-Hartman, la cual se puede encontrar aquí:

https://www.kernel.org/doc/Documentation/CodingStyle

Excelente y cálida lectura, dotada del característico humor de Greg. No te la
pierdas.

		Capítulo 1: Indentación
Los tabs son de 8 caracteres y por ello, la indentación es de 8 caracteres.

Fundamentación: La idea detras de la indentación es definir claramente donde
comienza y termina un bloque de control. Los tabs largos ayudan especialmente
luego de sesiones de programación de varias horas.

Ahora bien, algunas personas insisten en que tener una indentación de más de 3
niveles con el largo de 8 caracteres hace que el código quede desplazado muy a
la derecha. La respuesta para este argumento suele ser que si necesitas 3
niveles de indentación en tu programa, estás al horno de todas maneras y
necesitas arreglar tu programa. Seguramente existe una forma mejor de escribir
eso que estás tratando. Si no te sale, consulta con tu ayudante.

La forma preferida de indentar una sentencia switch es alineando el "switch" con
sus "case" subordinados al mismo nivel en lugar de indentar los cas. Por
ejemplo:
	switch (suffix) {
	case 'G':
	case 'g':
		mem <<= 30;
		break;
	case 'M':
	case 'm':
		mem <<= 20;
		break;
	case 'K':
	case 'k':
		mem <<= 10;
		/* fall through */
	default:
		break;
	}
No pongas múltiples sentecias en una linea a menos que tengas algo que esconder:
	if (condition) hacer_esto;
  	  hacer_esto_todas_las_veces;
No pongas asignaciones múltiples en una sola linea. Evita expresiones que sean
difíciles de interpretar.

Indentá usando tabs, no espacios. El ejemplo anterior está mal a propósito.

Usá un editor bueno. Hay muchos y se configuran de diferente forma. Elegí uno
que te permita coloreado de sintaxis, configurar la longitud de los tabs,
mostrar tabs y espacios, ajustar el ancho de las columnas, etc.

		Capítulo 2: Lineas largas y strings
Las convenciones de codificación son acerca de legibilidad y mantenibilidad
usando las herramientas disponibles para todos. Como no todos tenemos un monitor
wide de 26'', el límite para el largo de las lineas se establece a 80 columnas. 

Las sentecias más largas de 80 columnas deben partise en bloques con cierto
sentido. Los parámetros formales de un encabezado pueden indentarse como sigue:

	int funcion_con_muchos_argumentos ( int argumento_uno, char argumento_dos,
					char * argumento_tres,
					double argumento_cuatro,
					struct node * argumento_cinco);

		Capítulo 3:  Llaves y espacios
Al contrario de las lineas largas, no hay motivos técnicos para elegir una
convención para poner las llaves. Siguiendo el estilo del Kernel Linux que se
basa en lo que los profetas Kernighan y Ritchie nos enseñaron, las llaves de
apertura van al final de la sentecia que inicia el bloque y la de cierre, al
principio de la linea que cierra el bloque.
	if (x es verdader) {
		hacemos y;
		hacemos z;
	}

Esto aplica para todas las sentencias de bloque que no sean funciones (if,
switch, for, while, do).
	switch (action) {
	case KOBJ_ADD:
		return "add";
	case KOBJ_REMOVE:
		return "remove";
	case KOBJ_CHANGE:
		return "change";
	default:
		return NULL;
	}

Sin embargo, las funciones deben llevar la llave de apertura en la linea
siguiente al encabezado de la función. 
	int function(int x)
	{
		cuerpo de la funcion
	}

Esta inconsistencia ha sido vista por muchos como, bueno... incosistente. Por
ello, es posible poner la llave de apertura en la misma linea de la función si
la linea de los argumentos no está cortada. 
	int function(int x){
		cuerpo de la funcion
	}
	
Sin embargo, si la función está definida en varias lineas, es conveniente usar
la primera forma

	int funcion_con_muchos_argumentos ( int argumento_uno, char argumento_dos,
					char * argumento_tres,
					double argumento_cuatro,
					struct node * argumento_cinco)
	{
		cuerpo de la funcion
	}

Cualquiera sea el estilo que uses, mantenélo a lo largo de tu programa. No
mezcles ambos. Usa uno o el otro, pero no ambos.

Las llaves de cierre van solas en una linea excepto en la sentencia do-while.

	do {
		body of do-loop
	} while (condition);

Usá llaves aún si el bloque no lo necesita. 

	if (condicion){
		accion;
	}

Esto evita errores difíciles de depurar cuando agrego acciones al if por
habermelas olvidado. Por ejemplo, en el siguiente caso la accion_dos se ejecuta
aunque la condición sea falsa

	if (condicion)
		accion_uno;
		accion_dos;

		Sección 3.1: Espacios

Utilizá espacios luego de las palabras clave if, switch, case, for, do o while. 

	switch (action) {
	case KOBJ_ADD:
		return "add";
	case KOBJ_REMOVE:
		return "remove";
	case KOBJ_CHANGE:
		return "change";
	default:
		return NULL;
	}

Los operadores  =  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  : deben
tener un espacio a cada lado

	if (algo <= otra_cosa){
		x += algo;
	}
	else{
		x++;
	}

Los operadores unarios &  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__
defined ++  -- y los binarios para acceder a estructuras "." y "->" NO DEBEN
llevar espacios.

Cuando declares punteros a datos o funciones, se prefiere que el * este pegado
al identificador y no al tipo.
	char *linux_banner;
        unsigned long long memparse(char *ptr, char **retptr);
        char *match_strdup(substring_t *s);

Cuidá de no dejar espacios al final de una linea ni entre las expresiones
parentizadas. El siguiente ejemplo es NO RESPETA el las convenciones. Los puntos
representan espacios en blanco.

	s.=.sizeof(.struct.file.);......

También recordá agregar una linea en blanco entre funciones.

	int funcion_uno (){
		cuerpo de la funcion
	}

	char funcion_dos(){
		cuerpo de la funcion
	}

		Capítulo 4: Nombres

C es un lenguaje compacto y así deben ser las convenciones para los nombres. A
diferencia de los programadores de Java o Pascal, un programador C rara vez
usará nombres como EstaVariablesEsUnContadorTemporal. Por el contrario, le
pondrá tmp, que es mucho más fácil de escribir y no se pierde claridad.

Sin embargo, a pesar de que los nombres en camel case están desaconsejados,
poner nombres descriptivos para las variables globales es una OBLIGACIÓN!. Poner
como nombre a un identificador global "foo" o "bar" es una ofenza que será
castigada. 

Usa variables GLOBALES solo si es necesario y utilizá nombres descriptivos para
estas. Si una función o variable es usada para contar la cantidad de usuarios
globales debe tener un nombre descriptivo como "contar_usuarios_activos()" y no
algo como "ctarusrs()".

Por el contrario, las variables LOCALES deben tener nombres cortos y concisos.
Un contardor para un bucle llevará el nombre "i" y no "loop_counter".

		Capítulo 5: Typedefs
/*
 * TODO: Revisar esto a ver que opina el resto.
 */

El uso inadecuado de la instrucción typedef puede llevar a problemas de lo más
variados. Es un error usar typedef para estructuras o punteros. Cuando vez algo
como 

	vcp_t a;

¿qué significa? Si por el contrario vez algo como 

	struct virtual_container *a;

es mucho más claro. Sin embargo hay algunos casos donde si conviene usarlo:

  (a) Objetos totalmente opacos: Una lista por ejemplo, debería ser accedida a
travez de sus métodos declarados o accesors. En este caso, la estructura que
representa la lista puede ser un typedef.

  (b) Otros usos permitidos son los que aparecen en el Linux Kernel Coding
Style, pero básicamente, si no estás creando un tipo nuevo, no uses typedef.

		Capítulo 6: Funciones

Las funciones deben ser cortas y concisas, hacer una sola cosa y hacerla bien.
En general no deben ocupar mas de una o dos pantallas de 80 columnas por 24
filas.

Si la función hace muchas cosas muy sencillas, como procesar un switch con
muchos casos donde por cada uno se hace una cosa muy cortita, está bien tener
funciones más largas. Pero si por el contario, la función es compleja y
sospechas que el menos dotado de los alumnos de primer año no va a entender que
es lo que hace, deberías atenerte a los límites sugeridos lo más posible. 

Otro parámetro a tener en cuenta es que la cantidad de variables locales por
función no debe ser de más de 5-10. Si así pasara, seguramente estás haciendo
algo mal. Re pensa la función o dividila en partes más pequeñas.

Además, en los prototipos de las funciones SIEMPRE incluí el nombre de los
parámetros además del tipo. Pese a que esto no es requerido por el lenguaje C,
agrega información muy valiosa para los lectores del programa.

		Capítulo 7: Centraliced exiting of functions

Si bien NO va a usarse durante la cursada ya que no se preveen sistemas tan
complejos que lo requieran, vale la pena leer el capítulo 7 del Linux kernel
coding style para hacerce una idea de cuando puede usarse la instrucción goto en
forma sumamente justificada ;)

		Capítulo 8: Comentarios

Los comentarios son buenos, siempre y cuando se usen bien. NUNCA trates de
explicar COMO funciona tu código. Es más sencillo escribir el código de forma
que se entienda lo que se pretende hacer. De esa forma, el COMO está implísito
en el código. Es una perdida de tiempo comentar código mal escrito.

Generalmente, lo que se quiere comentar es QUE hace el código y no COMO lo hace.
Tratá de evitar los comentarios dentro de una función. Si tu función es muy
compleja y requiere que comentes algunos fragmentos es probable que debas
revisar nuevamente el capítulo 6. Está bien comentar algo que te parezca
particularmente ingenioso (o chancho), pero evitá los excesos (sobre todo de lo
chancho ;)). Colocá los comentarios  (si hacen falta) antes del comienzo de la
función para que la gente sepa QUE hace y si es posible, POR QUE lo hace.

Utilizá siempre los comentarios estilo C89 /*...*/, tratando de evitar los
comentarios de C99 //.

La forma más prolija y preferida para los comentarios es la del kernel.

	/*
	 * This is the preferred style for multi-line
	 * comments in the Linux kernel source code.
	 * Please use it consistently.
	 *
	 * Description:  A column of asterisks on the left side,
	 * with beginning and ending almost-blank lines.
	 */

A veces también es necesario comentar los datos. Usá una declaración por linea
sin comas o declaraciones multiples. De esta manera queda espacio para un
pequeño comentario si hiciera falta, al final de la linea.

		Capítulo 9: Macros

Los nombres de las macros que definan constantes o etiquetas para enums deben
estar capitalizadas.

#define CONSTANT 0x12345

Los nombres de macros deben estar CAPITALIZADOS excepto en las macros con
parámetros, en los cuales pueden utilizarse nombres sin capitalización.

A evitar cuando utilices macros:

1) macros que modifiquen el flujo de control el programa:

#define FOO(x)					\
	do {					\
		if (blah(x) < 0)		\
			return -EBUGGERED;	\
	} while(0)

Es una MUY mala idea. La macro parece una función, pero el return sale de la
función que llamó a la macro.

2) macros que dependen de una variable local

#define FOO(val) bar(index, val)

Parece una buena idea, pero confunde un montón y es probable que se rompa con el
más inocente de los cambios.

3) macros con argumentos que pueden ser usados como l-values:

FOO(x) = y;

Esto puede explotar si por ejemplo alguien transforma una macro en una función
inline.

4) las macros que definen constantes usando expresiones deben ir entre
parentesis.

#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)

		Capítulo 10: Valores devueltos por las funciones

Las funciones pueden retornar cosas de diferentes tipos y uno de los valores más
comunes es la indicación de si la función falló o tuvo éxito. Tal valor puede
representarse como un código de error entero (-Exxx = error, 0 = éxito) o como
un "exito" booleano (0 = error, no-cero = éxito).

Mezclar los dos tipos de representaciones en un programa es una fuente fértil de
errores difíciles de detectar. Para ayudar a prevenir tales errores procedé
siempre de la siguiente manera:

	Si el nombre de la función es una acción o un comando imperativo, la función
debe retornar un código de error en caso que no haya tenido éxito o cero en caso
contrario. Si el nombre de la función es un predicado, entonces debe retornar un
"exito" booleano.

Por ejemplo, una función que agregue un elemento a una lista puede llamarse
add_elem(). Si pudo agregar el elemento sin problemas, la función devuelve 0. Si
no pudo agregar el elemento a la lista, por el motivo que fuera, deberá retornar
por ejemplo -ENOMEM donde ENOMEM es una macro que indica un código de error
acerca de que no hay más memoria disponible.

Por el contrario, la función que retorna si la lista es vacia o no, se llamará
is_empty() y retornará verdadero si la lista está vacía o falso en caso
contrario. Siempre que puedas, para casos como éste utilizá los tipos booleanos
disponibles en C99.

													por Joaquin Bogado
