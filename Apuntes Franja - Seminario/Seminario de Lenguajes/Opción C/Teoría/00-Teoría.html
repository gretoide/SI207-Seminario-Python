<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">

<title>Slides</title>

<meta name="description" content="">
<meta name="author" content="">
<meta name="generator" content="reveal-ck 3.3.1">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<link rel="stylesheet" href="css/reveal-ck.css">

<link rel="stylesheet" href="css/custom.css">

<!-- Printing and PDF exports -->
<script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->

  </head>

  <body>
    <div class="reveal">
  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">
    <section>

<h2>Seminario de Lenguajes</h2>

<h3>Opción C</h3>

</section>
<section>
<section>

<h1>La cátedra</h1>

</section>
<section>

<h2>Profesores</h2>

<ul>
<li>Ana Paola Amadeo

<ul>
<li><a href="mailto:pamadeo@info.unlp.edu.ar">pamadeo@info.unlp.edu.ar</a></li>
</ul>
</li>
<li>Christian A. Rodriguez

<ul>
<li><a href="mailto:car@info.unlp.edu.ar">car@info.unlp.edu.ar</a></li>
<li><a href="https://twitter.com/car_unlp">@car_unlp</a></li>
<li><a href="https://github.com/chrodriguez">https://github.com/chrodriguez</a></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Jefes de Trabajos Prácticos</h2>

<ul>
<li>Andrés Barbieri</li>
<li>Fernando López</li>
<li>Nahuel Cuesta Luengo</li>
</ul>

</section>
<section>

<h2>Ayudantes (2017)</h2>

<ul>
<li>Adán Mauri Ungaro</li>
<li>Carina Girón</li>
<li>Matías Ferrigno</li>
<li>Federico Tello Gentile</li>
<li>Javier Benitez Alvarenga</li>
<li>Emilia Corrons</li>
<li>Rosario Santa Marina</li>
<li>Valeria Soria</li>
<li>Lucas Di Cunzolo </li>
<li>Leandro Di Tommaso</li>
<li>Valentín Mari</li>
</ul>

</section>
</section>
<section>

<h1>Contacto</h1>

<ul>
<li><a href="https://catedras.info.unlp.edu.ar">https://catedras.info.unlp.edu.ar</a></li>
<li><a href="mailto:lenguajec@info.unlp.edu.ar">lenguajec@info.unlp.edu.ar</a></li>
</ul>

</section>
<section>
<section>

<h1>Horarios</h1>

</section>
<section>

<h2>Horarios de Teoría</h2>

<ul>
<li>
<strong>Turno Tarde</strong>

<ul>
<li>Jueves de 17:00hs a 18:30 Aula 1-1</li>
</ul>
</li>
<li>
<strong>Turno Mañana</strong>

<ul>
<li>Martes de 9:30hs a 11:00hs Aula 1-1</li>
</ul>
</li>
</ul>

<p class="fragment">
<em>  Los alumnos optarán el turno al que asistirán según su disponibilidad horaria </em>
</p>

</section>
<section>

<h2>Horarios de Práctica</h2>

<ul>
<li>Martes de 8:00hs a 9:30hs Aula 1-1</li>
<li>Miércoles 13:30 a 15:00 Sala de PC</li>
<li>Jueves de 18:30hs a 20:00hs Aula 1</li>
<li>Viernes de 11:30hs a 13:30hs Aula 1-1</li>
</ul>

</section>
</section>
<section>

<h2>Bibliografía</h2>

<ul>
<li>El Lenguaje C. Kernighan &amp; Ritchie</li>
<li>C con ejemplos. Perry, Greg</li>
<li>Efficient C programming. Weiss, Mark Allen</li>
<li>C in a nutshell. Prinz, Peter
<p class="fragment">
<a href="http://catalogo.info.unlp.edu.ar">http://catalogo.info.unlp.edu.ar</a>
</p>
</li>
</ul>

</section>
<section>

<h2>Modo de aprobación</h2>

<p class="fragment" style="text-align: left;">
La <strong>aprobación de la cursada</strong> estará dada por la aprobación de cuatro evaluaciones
en máquina presenciales:
</p>

<ul>
<li class="fragment">Si se aprueban las cuatro evaluaciones no se rinde parcial integrador</li>
<li class="fragment">Cada evaluación desaprobada se rendirá como un tema en el parcial
integrador</li>
<li class="fragment">Puede no aprobarse ninguna evaluación, siendo necesario rendir el parcial
integrador completo</li>
<li class="fragment">TP integrador individual defendible en un coloquio</li>
</ul>

</section>
<section>

<h2>Aprobación de la materia</h2>

<ul>
<li>La <strong>aprobación de la materia</strong> estará dada por la aprobación de la Cursada</li>
<li>Con ella se obtiene un <strong>6 (seis)</strong>
</li>
</ul>

<p><em>Si se desea mejorar la nota se podrá realizar una extensión del trabajo 
realizado en la cursada. La nota final se promediará con
el desempeño durante la cursada</em></p>

</section>
<section>

<h1>Clase 1</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Historia de C</li>
<li>Características generales</li>
<li>Compilación de un programa</li>
<li>Tipos de datos</li>
<li>Variables</li>
<li>Operadores</li>
</ul>

</section>
<section>
<section>

<h1>Historia de C</h1>

</section>
<section>

<h2>Un poco de historia</h2>

<ul>
<li>Desarrollador entre 1969/1973 por Dennis Ritchie </li>
<li>A fines de 1974 fue utilizado para reimplementar el sistema operativo Unix </li>
<li>En 1980 ANSI comenzó la estandarización del lenguaje</li>
<li>A partir de 1990, ISO adopta ANSI C en el estándar conocido como C89/C90</li>
<li>A fines de los '90s, se revisa el estándar y surge C99 que incorpora nuevas
características que fueron revolucionarias</li>
</ul>

</section>
<section>

<h2>Quiénes lo utilizan</h2>

<ul>
<li>Nuevos lenguajes mantienen expresiones similares en su sintaxis, como
por ejemplo: C++, PERL, Javascript, Java, PHP, entre otros.</li>
<li>En el desarrollo de sistemas operativos, bases de datos, juegos,
compiladores, nuevos lenguajes, etc.</li>
</ul>

<p class="fragment">
<em>Además, programar en C, motiva la adopción de buenas prácticas de programación</em>
</p>

</section>
<section>

<h2>Características</h2>

<ul>
<li>Combina elementos de alto nivel con características de bajo nivel</li>
<li>Es un lenguaje pequeño, con una sintaxis simple</li>
<li>Es orientado a expresiones</li>
<li>Es base de lenguajes modernos</li>
<li>Código <em>"portable"</em>
</li>
<li>Extensible mediante el uso de librerías</li>
<li>Contempla sólo tipos de datos básicos</li>
</ul>

</section>
<section>

<h2>Características</h2>

<ul>
<li>No es orientado a objetos</li>
<li>No es un lenguaje de bajo nivel</li>
<li>No provee primitivas de entrada salida</li>
<li>No realiza comprobación de errores en tiempo de ejecución</li>
</ul>

</section>
</section>

<section>
<section>

<h1>Proceso de compilación</h1>

</section>
<section>

<h2>Hola mundo!</h2>

<p>Asumiendo el archivo se llama <code>hola_mundo.c</code></p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() 
{
    printf("Hola Mundo\n");
    return (0);
}
</code></pre>
<pre><code class="bash">$ gcc hola_mundo.c -o hola_mundo -Wall
</code></pre>
<p><small>
<a href="images/ejemplos/01/01-hello-world.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Fases en la creación de un programa</h2>

<p><img src="images/01%20-%20Fases%20de%20compilacion.svg" alt="Fases de compilación"></p>

</section>
</section>

<section>
<section>

<h1>Tipos de datos</h1>

</section>
<section>

<h2>Tipos de datos</h2>

<ul>
<li>Definen la representación interna de una variable y un conjunto de valores
posibles.</li>
<li>La definición original de C era sumamente permisiva respecto de las
conversiones de tipos

<ul>
<li>Actualmente se requiere una adecuada declaración y conversión explícita</li>
</ul>
</li>
<li>Tipos de datos en C:

<ul>
<li>
<strong>Básicos:</strong> caracteres, enteros y números de punto flotante, punteros. </li>
<li>
<strong>Derivados:</strong> arreglos, estructuras y uniones. </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Tipos de datos básicos</h2>

<table>
<thead>
<tr>
<th>Tipo</th>
<th style="text-align: left">Descripción</th>
<th style="text-align: right">32bits</th>
<th style="text-align: right">64bits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td style="text-align: left">caracter</td>
<td style="text-align: right">8</td>
<td style="text-align: right">8</td>
</tr>
<tr>
<td><code>short</code></td>
<td style="text-align: left">entero corto con signo</td>
<td style="text-align: right">16</td>
<td style="text-align: right">16</td>
</tr>
<tr>
<td><code>int</code></td>
<td style="text-align: left">entero con signo</td>
<td style="text-align: right">32</td>
<td style="text-align: right">32</td>
</tr>
<tr>
<td><code>long</code></td>
<td style="text-align: left">entero largo con signo</td>
<td style="text-align: right">32</td>
<td style="text-align: right">64</td>
</tr>
</tbody>
</table>

</section>
<section>

<h2>Tipos de datos básicos</h2>

<table>
<thead>
<tr>
<th>Tipo</th>
<th style="text-align: left">Descripción</th>
<th style="text-align: right">32bits</th>
<th style="text-align: right">64bits</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>float</code></td>
<td style="text-align: left">flotante simple</td>
<td style="text-align: right">32</td>
<td style="text-align: right">32</td>
</tr>
<tr>
<td><code>double</code></td>
<td style="text-align: left">flotante doble</td>
<td style="text-align: right">64</td>
<td style="text-align: right">64</td>
</tr>
<tr>
<td><code>pointer</code></td>
<td style="text-align: left">puntero a una posición de memoria</td>
<td style="text-align: right">32</td>
<td style="text-align: right">64</td>
</tr>
<tr>
<td><code>void</code></td>
<td style="text-align: left">idem <code>char</code>. Empleado para tipos genéricos</td>
<td style="text-align: right">-</td>
<td style="text-align: right">-</td>
</tr>
</tbody>
</table>

<p class="fragment">
<em>No existe el tipo boolean</em>
</p>

</section>
<section>

<h2>Constantes literales: Punto Flotante</h2>

<p>La expresión:</p>
<pre><code class="c">3.45 – 1.2e+34
</code></pre>
<p>Significa <strong>3.45 - (1.2*10<sup>34</sup>)</strong></p>

</section>
<section>

<h2>Constantes literales: Enteros</h2>

<table>
<thead>
<tr>
<th style="text-align: left">Base</th>
<th style="text-align: right">Representación</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">Decimal</td>
<td style="text-align: right">14</td>
</tr>
<tr>
<td style="text-align: left">Hexadecimal</td>
<td style="text-align: right">0xE</td>
</tr>
<tr>
<td style="text-align: left">Octal</td>
<td style="text-align: right">016</td>
</tr>
</tbody>
</table>

</section>
<section>

<h2>Constantes literales: Enteros</h2>

<h3>Calificadores o modificadores</h3>

<p>Determinan si el entero es con signo, corto o largo:</p>

<table>
<thead>
<tr>
<th>Literal</th>
<th style="text-align: center">Representación</th>
<th style="text-align: center">Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>23L</code></td>
<td style="text-align: center">decimal</td>
<td style="text-align: center"><code>23 long int</code></td>
</tr>
<tr>
<td><code>23LU</code></td>
<td style="text-align: center">decimal</td>
<td style="text-align: center"><code>23 unsigned long int</code></td>
</tr>
<tr>
<td><code>023LU</code></td>
<td style="text-align: center">octal</td>
<td style="text-align: center"><code>19 unsigned long int</code></td>
</tr>
<tr>
<td><code>0XFUL</code></td>
<td style="text-align: center">hexadecimal</td>
<td style="text-align: center"><code>15 unsigned long int</code></td>
</tr>
</tbody>
</table>

<p><small>
<a href="images/ejemplos/01/02-0xful.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Constantes literales: Char</h2>

<ul>
<li>Permiten representar letras mayúsculas, minúsculas, números de 0 a 9, signos de
puntuación, no imprimibles, etc.</li>
<li>Se manejan como <code>char</code> o <code>int</code> (valor <a href="http://ascii.cl/es">ASCII</a>) de forma indistinta</li>
</ul>

</section>
<section>

<h2>Constantes literales: Char</h2>

<h3>Las comillas</h3>

<ul>
<li>
<strong>Comilla simple:</strong> usada para un char</li>
<li>
<strong>Comilla doble:</strong> usada para un string</li>
</ul>

</section>
<section>

<h2>Constantes literales: Char</h2>

<h3>Ejemplos</h3>

<table>
<thead>
<tr>
<th><code>char</code></th>
<th>Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'A'</code></td>
<td>Letra A mayúscula</td>
</tr>
<tr>
<td><code>'\n'</code></td>
<td>Salto de linea. Equivale a <code>'\x0A'</code>
</td>
</tr>
<tr>
<td><code>'\0'</code></td>
<td>Fin de string o <code>NULL</code> o cero</td>
</tr>
<tr>
<td><code>'\x0A'</code></td>
<td>Idem <code>'\n'</code> en hexadecimal</td>
</tr>
<tr>
<td><code>'\012'</code></td>
<td>Idem <code>'\n'</code> en octal</td>
</tr>
</tbody>
</table>

</section>
<section>

<h2>Constantes literales: Char</h2>

<h3>Los strings</h3>

<ul>
<li>Los strings se representan con <strong>comillas dobles</strong>.</li>
<li>Por ello, <strong><code>'A'</code> no es lo mismo que "A"</strong>
</li>
<li>El string "A" es un arreglo con los siguientes elementos: <code>['A','\0']</code>
</li>
</ul>

</section>
<section>

<h2>Constantes enumerativas: Enum</h2>

<p>Se utilizan para enumerar una lista de valores constantes</p>
<pre><code class="c">enum estado_civil {casado, soltero, viudo, separado, divorciado, NSNC,
estado_civil_TOPE };

enum meses { ENE=1, FEB, MAR, ABR, MAY, JUN, JUL, AGO, SEP, OCT, NOV, DIC,
meses_TOPE };

</code></pre>
<p><small>
<a href="images/ejemplos/01/03-enum-sample.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Punteros</h2>

<ul>
<li>Representan una variable que apunta a otra</li>
<li>Contienen la dirección de memoria de otra variable</li>
<li>Un puntero consta de dos partes:

<ul>
<li>La dirección apuntada</li>
<li>El contenido apuntado.</li>
</ul>
</li>
</ul>

</section>
<section>

<h3>Conceptos del manejo de memoria</h3>

<ul>
<li>Cada posición de memoria:

<ul>
<li>Almacena un byte</li>
<li>Es accesible mediante una dirección específica</li>
</ul>
</li>
<li>Las direcciones de memoria son consecutivas</li>
<li>Dependiendo del tipo de memoria al que apunte un puntero, la
memoria accederá a todos los bytes que representen ese tipo.</li>
<li>Los programas comparten el espacio de direcciones con el sistema operativo</li>
<li>Los datos del programa y el programa se almacenan en memoria al ser ejecutados</li>
</ul>

</section>
<section>

<h3>Distribución de la memoria</h3>

<ul>
<li>La memoria de un programa en ejecución se organiza en segmentos

<ul>
<li>
<strong>Text segment:</strong> código compilado  del programa</li>
<li>
<strong>Stack segment:</strong> almacena <em>variables automáticas</em> declaradas en funciones</li>
<li>
<strong>Heap segment:</strong> almacena <em>datos dinámicos</em>
</li>
</ul>
</li>
</ul>

<p><img src="images/02-memory-segments.svg" alt="Fases de compilación"></p>

</section>
<section>

<h3>Distribución de la memoria</h3>
<pre><code class="c">int x;        /* Variable global */

int main() {

  int y;      /* Variable automatica */

  char *str;  /* Variable automatica cuyo valor es la posición
               * de memoria de otra variable
               */

  str = malloc(50); /* Es en esta instancia donde se aloca memoria
                     * en la heap 
                     */
  ...
}
</code></pre>
</section>
<section>

<h2>Esquema de memoria</h2>
<pre><code class="c">int main( ) {

  int v_entero;
  int *p;
  v_entero = 7;
  p = &amp;v_entero;
  ...
</code></pre>
</section>
<section>

<h2>Esquema de memoria: gráfico</h2>

<table>
<tr>
<td class="fragment">
<img src="images/03-memory-alignement-00.svg">
</td>
<td class="fragment">
<img src="images/03-memory-alignement-01.svg">
</td>
<td class="fragment">
<img src="images/03-memory-alignement-02.svg">
</td>
</tr>
</table>

</section>
</section>

<section>
<section>

<h1>Variables</h1>

</section>
<section>

<h2>Variables</h2>

<ul>
<li>Representa una posición de memoria que se le asigna un nombre y posee un cierto tipo de
datos</li>
<li>Se usan en expresiones para realizar cálculos</li>
<li>Deben ser declaradas antes de ser utilizadas.</li>
<li>El operador <code>&amp;</code> permite acceder a la dirección de la variable</li>
<li>Son sensibles a mayúsculas y minúsculas</li>
</ul>

</section>
<section>

<h2>Variables: inicialización</h2>

<p>Es posible realizar la incialización en la declaración</p>
<pre><code class="c">int x = 9;
int j, x = 12;
int j = 12, x;
char c = 'x';
const int x = 12;
char c, linea[80];
char nombre[] = "Juan";
const char mensaje[] = "Saludos!!";
</code></pre>
<p class="fragment">
<em>Recordar que las últimas dos cadenas son arreglos de <strong>char</strong> terminadas en
<strong>'\0'</strong></em>
</p>
<pre class="fragment">
<code class="c">
['J','u','a','n','\0']
['S', 'a', 'l', 'u', 'd', 'o', 's', '!', '!', '\0']
</code>
</pre>


</section>
<section>

<h2>Conversiones de tipos</h2>

<ul>
<li>Es posible <em>mezclar</em> tipos de datos en una expresión:

<ul>
<li>
<strong>Conversiones explícitas:</strong> <code>(tipo) expresion</code>
</li>
<li>
<strong>Conversiones implícitas:</strong> <code>lvalue = rvalue</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Conversiones implícitas</h2>

<ul>
<li>De <code>int</code> a <code>char</code> se eliminan los bits de orden superior</li>
<li>De <code>float</code> a <code>int</code> se trunca la parte fraccionaria</li>
<li>De <code>double</code> a <code>float</code> se aplica redondeo</li>
<li>Los enteros de mayor magnitud (como <code>long</code>) se convierten en <code>short</code> o en <code>char</code>
eliminando los bits de orden superior</li>
</ul>

<p><small>
<a href="images/ejemplos/01/04-cast-conversion.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Conversiones implícitas: Reglas</h2>

<ul>
<li>Si cualquier operando es <code>long double</code>, se convierte el otro a <code>long double</code>
</li>
<li>De otra manera, si cualquier operando es <code>double</code>, se convierte el otro a <code>double</code>
</li>
<li>De otra manera, si cualquier operando es <code>float</code>, se convierte el otro a <code>float</code>
</li>
<li>De otra manera, si cualquier operando es <code>long</code>, se convierte el otro a <code>long</code>
</li>
<li>De otra manera, si cualquier operando es <code>int</code>, se convierte el otro a <code>int</code>
</li>
<li>Finalmente, se convierte <code>char</code> a <code>short</code>
</li>
</ul>

</section>
<section>

<h2>Conversiones implícitas: Ejemplo</h2>

<p>Asumiendo el siguiente código</p>
<pre><code class="c">  int x = 64, y = 357;
  float f = 4.95;
  char c;
  c = x;
  x = c;
  c = y;
  y = c;
  y = f;
</code></pre>
<p class="fragment">
¿Con qué valores quedan <strong>x, y, f, c</strong>?
</p>

<p><small class="fragment">
<a href="images/ejemplos/01/05-implicit-conversion.c">Descargar ejemplo</a>
</small></p>

</section>
</section>

<section>
<section>

<h1>Operadores</h1>

</section>
<section>

<h2>Operadores</h2>

<ul>
<li>Son elementos del lenguaje que se aplican a variables o literales en una
expresión:

<ul>
<li>
<strong>Asignación:</strong> <code>=</code> retorna el valor asignado, de forma tal de permitir
asignaciones encadenadas</li>
<li>
<strong>Operadores artiméticos:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>
</li>
<li>
<strong>Operadores lógicos:</strong> <code>&amp;&amp;</code>, <code>||</code> <code>!</code>
</li>
<li>
<strong>Operadores relacionales:</strong> <code>==</code>, <code>!=</code>,<code>&lt;</code>, <code>&gt;</code>,<code>..</code>
</li>
</ul>
</li>
</ul>

<p class="fragment highlight-red">
Cualquier valor distinto de 0 (cero) es <strong>VERDADERO</strong>.  El 0 (cero) es <strong>FALSO</strong>
</p>

</section>
<section>

<h2>Operadores: errores</h2>

<p>Es común usar de forma equivocada el símbolo <code>=</code> como comparación</p>
<pre><code class="c">int x = 3;

if ( x = 3 ) /* siempre será true */

if ( x == 3 ) /* Uso correcto */
</code></pre>
</section>
<section>

<h2>Operadores: asignación</h2>

<p>Se definen los operadores <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, etc</p>

<p>Permiten realizar una asignación <em>comprimida</em></p>
<pre><code class="c">
x += 6;  /* equivale a x = x + 6  */

</code></pre>
</section>
<section>

<h2>Operadores: pre/post-incremento</h2>

<p>Permiten incrementar/decrementar una variable en 1</p>

<p>Puede ser en forma prefija o postfija:</p>
<pre><code class="c">
x++;

++x;

/*  Ambos equivalen a x = x + 1 */
</code></pre>
<p>¿Con qué valores quedan?</p>
<pre><code class="c">int n = 5, x, y;

x = ++n;

y = n++;
</code></pre>
<p><small>
<a href="images/ejemplos/01/06-pre-post-operator.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Más operadores</h2>

<p>El operador condicional <strong>if then else: <code>_?_:_</code></strong></p>
<pre><code class="c">
e1 ? e2 : e3

</code></pre>
<p>El operador <code>sizeof</code> que devuelve el tamaño de un tipo o variable</p>
<pre><code class="c">int x=2;

sizeof(x);

sizeof(int);
</code></pre>
<p><small>
<a href="images/ejemplos/01/07-sizeof-types.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Operadores para manipular bits</h2>

<ul>
<li>
<code>&amp;</code> (AND), <code>|</code> (OR), <code>^</code> (OR exclusivo), <code>&lt;&lt;</code>, <code>&gt;&gt;</code> (desplazamientos de bits a derecha o
izquierda), <code>~</code>(complemento a 1)</li>
<li>No se aplican a operandos del tipo float o double</li>
<li>No se debe confundir con los operadores lógicos <code>&amp;&amp;</code> y con <code>||</code>
</li>
</ul>

<p><small>
<a href="images/ejemplos/01/08-masq.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Operadores: precedencia</h2>

<ul>
<li><code>() [] -&gt;</code></li>
<li><code>! ~  ++ -- - (tipo) * &amp; sizeof</code></li>
<li><code>* / %</code></li>
<li><code>+ -</code></li>
<li><code>&lt;&lt; &gt;&gt;</code></li>
<li><code>== !=</code></li>
</ul>

<p><small>
continúa...
</small></p>

</section>
<section>

<h2>Operadores: precedencia</h2>

<ul>
<li><code>&amp;</code></li>
<li><code>^</code></li>
<li><code>|</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
<li><code>?</code></li>
<li><code>= += -= *= /=</code></li>
<li><code>,</code></li>
</ul>

</section>
</section>
<section>

<h1>Clase 2</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Estructuras de control

<ul>
<li>Sentencias compuestas</li>
<li>Condicional simple</li>
<li>Switch</li>
<li>Iteraciones</li>
</ul>
</li>
</ul>

</section>
<section>
<section>

<h1>Estructuras de control</h1>

</section>
<section>

<h2>Estructuras de control</h2>

<ul>
<li>Gobiernan la ejecución de un programa</li>
<li>Permiten repetir código o saltear algún conjunto de sentencias.</li>
</ul>

</section>
</section>

<section>
<section>

<h1>Sentencias compuestas</h1>

</section>
<section>

<h2>Sentencias compuestas</h2>

<ul>
<li>También llamadas bloques</li>
<li>Suelen ser parte de otras estructuras como <code>if</code>, <code>for</code> , <code>while</code>, etc</li>
<li>Consiste de varias sentencias encerradas entre llaves <code>{ }</code>
</li>
<li>No terminan con <code>;</code>
</li>
</ul>
<pre><code class="c">{
  int x = 12;
  y = x*2;
}
</code></pre>
<p><small>
<a href="images/ejemplos/02/01-block.c">Descargar ejemplo</a>
</small></p>

</section>
</section>

<section>
<section>

<h1>Condicional simple</h1>

</section>
<section>

<h2>Condicional simple: if</h2>
<pre><code class="c">if (condicion) {
  sentencias_verdad
} else {
  sentencias_falso
}
</code></pre>
<h3>Ejemplo</h3>
<pre><code>if (x == 3) {
  ...
} else {
  ...
}
</code></pre>
</section>
<section>

<h2>Buenas prácticas</h2>

<h3>En vez de....</h3>
<pre><code class="c">if (x != 0) {
...
}

if (x == 0) {
...
}
</code></pre>
<div class="fragment">
<h3> Usar... </h3>

<pre>
<code class="c">
if (x) {
...
}

if (!x) {
...
}
</code>
</pre>
</div>

</section>
</section>

<section>
<section>

<h1>Condicional compuesto</h1>

</section>
<section>

<h2>Condicional compuesto: switch</h2>
<pre><code class="c">switch (expresión) {
  case expresion-constante: sentencias
  case expresion-constante: sentencias
  case expresion-constante: sentencias
  default: sentencias
}
</code></pre>
</section>
<section>

<h3>Ejemplo</h3>
<pre><code class="c">...
switch (letra) {
  case 'a': case 'e': case 'i': case 'o': case 'u':
    vocMin++;
    break;
  case 'A': case 'E': case 'I': case 'O': case 'U':
    vocMay++;
    break;
  default:
    otros++;
    break;
}
...
</code></pre>
<p><small>
<a href="images/ejemplos/02/02-switch.c">Descargar ejemplo</a>
<div class="fragment">
El ejemplo lee las palabras como argumentos al programa
</div>
</small></p>

</section>
</section>

<section>
<section>

<h1>Iteraciones</h1>

</section>
<section>

<h2>Iteraciones: while</h2>
<pre><code class="c">while (expresión)
  sentencias
</code></pre>
<h3>Ejemplo</h3>
<pre><code class="c">int suma=0,n=10;
while (n--) {
  suma += n;
  ....
}

/* Similar a 
while (n) {
  n = n - 1;
  suma = suma + n;
  ...
*/
</code></pre>
</section>
<section>

<h2>Iteraciones: do while</h2>
<pre><code class="c">do
  sentencias
while (expresión)
</code></pre>
<h3>Ejemplo</h3>
<pre><code class="c">int sumo = 0, n = 10;
do
  sumo += n
while (n--);
</code></pre>
<p><small>
<a href="images/ejemplos/02/03-do-while.c">Descargar ejemplo</a>
<div class="fragment">
El ejemplo retorna el valor calculado. Este valor puede verse con <code>echo $?</code>
</div>
</small></p>

</section>
<section>

<h2>Iteraciones: for</h2>

<h3>El for siguiente...</h3>
<pre><code class="c">for (expresión1; expresión2; expresión3)
  sentencias;
</code></pre>
<div class="fragment">
<h3> Equivale a...</h3>
<pre>
<code class="c">
expresión1;
while (expresión2) {
  sentencias;
  expresión3
}
</code>
</pre>
</div>

</section>
<section>

<h2>Iteraciones: for</h2>

<h3>Versión 1</h3>
<pre><code class="c">int suma=0,n;
for( n=1; n &lt;=10;n++)
  suma+=n;
</code></pre>
<h3>Versión 2</h3>
<pre><code class="c">int suma=0, n=5;
for( ; n &lt;=10;suma+=n, n++);
</code></pre>
<h3>Versión 3</h3>
<pre><code class="c">int suma=0, n=1;
for( ; n &lt;=10; ) {
  suma+=n;
  n++;
}
</code></pre>
</section>
</section>
<section>

<h1>Clase 3</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Estructura de un programa</li>
<li>Funciones y prototipos</li>
<li>Entrada / Salida</li>
</ul>

</section>
<section>
<section>

<h1>Estructura de un programa</h1>

</section>
<section>

<h2>Estructura de un programa</h2>

<ul>
<li>Conjunto de funciones disjuntas</li>
<li>No hay anidamiento de funciones</li>
<li>Función <code>main()</code>
</li>
<li>Prototipos</li>
<li>Compilación separada

<ul>
<li>Archivos .c y .h</li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h1>Funciones y prototipos</h1>

</section>
<section>

<h2>Funciones en C</h2>
<pre><code class="c">
tipo_retornado nombre_función(lista de_argumentos)
{
  declaraciones_y_sentencias;
  [return expresion;]
}

</code></pre>
<ul>
<li>Si se omite el tipo_retornado se asume <code>int</code>
</li>
<li>Si la lista de_argumentos es vacía o la función retorna vacío usar la palabra clave <code>void</code>
</li>
<li>Argumentos sólo por valor</li>
</ul>

</section>
<section>

<h3>Ejemplo</h3>
<pre><code class="c">
int sumo_n (int n)
{
  int suma=0;

  for (; n&gt;0; suma += n, n--);

  return suma;
}

</code></pre>
</section>
<section>

<h3>Función main</h3>
<pre><code class="c">
#include &lt;stdio.h&gt;

int main()
{
  printf (“Hola Mundo”);

  return 0;
}

</code></pre>
</section>
<section>

<h3>Prototipo de una función</h3>

<ul>
<li>Las funciones deben ser declaradas antes de ser utilizadas</li>
<li>Permiten que el compilador lleve a cabo una fuerte comprobación de tipos</li>
<li>Valida también la cantidad de parámetros</li>
<li>Se incluyen antes de las funciones de nuestro programa, al principio del archivo</li>
<li>Se usa la palabra clave <code>void</code> para indicar el no retorno de valor por una función y una lista de argumentos vacía</li>
<li>No es necesario dar nombre a las variables en la lista de argumentos</li>
<li>Colabora con la modularización y construcción de librerías.</li>
</ul>
<pre><code class="c">
tipo nombre_funcion (tipo_p1, tipo_p2, tipo_p3)

</code></pre>
</section>
</section>

<section>
<section>

<h1>Entrada/Salida</h1>

</section>
<section>

<h2>Funciones de Entrada/Salida</h2>

<ul>
<li>C no prove palabras claves para realizar E/S</li>
<li>Librería <code>stdio.h</code> de la biblioteca estándard</li>
<li>Existen funciones para la E/S por <em>consola</em> y por <em>archivo</em>, aunque técnicamente son similares conceptualmente son diferentes.</li>
</ul>

</section>
<section>

<h2>Entrada / Salida estándar</h2>

<ul>
<li>Archivos estándar 

<ul>
<li>
<code>STDIN</code>: Standard Input</li>
<li>
<code>STDOUT</code>: Standard Output</li>
<li>
<code>STDERR</code>: Standard Error</li>
</ul>
</li>
<li>También se pueden redirigir

<ul>
<li>
<code>STDIN</code>:  se puede redirigir con <code>&lt;</code>
</li>
<li>
<code>STDOUT</code>: se puede redirigir con <code>&gt;</code>
</li>
<li>
<code>STDERR</code>: se puede redirigir con <code>2&gt;</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Entrada y Salida de Caracteres</h2>
<pre><code class="c">
int getchar(void);

int putchar(int c);

</code></pre>
<ul>
<li>
<code>getchar()</code> devuelve un entero pero se puede asignar a un char. Esto es porque
devuelve <code>EOF</code> cuando se produce un error o alcanza el fin de archivo</li>
<li><p><code>EOF</code> es <code>-1</code> que no es un valor válido para un char.</p></li>
<li><p>putchar(int) envía a la salida estándar el caracter escrito. Envía el byte menos  significativo.</p></li>
</ul>

</section>
<section>

<h2>Buffer intermedio</h2>

<ul>
<li>La función <code>getchar()</code> toma los datos de un buffer intermedio, temportal, que se carga
con lo que ingresa el usuario desde teclado (<code>STDIN</code>)</li>
<li>Lo maneja internamente el Sistema Operativo</li>
</ul>

<p><img src="images/3-1-%20buffer-io.png" alt="Buffer intermedio"></p>

</section>
<section>

<h2>Buffer intermedio: ejemplo</h2>

<p>Si un programa presenta en pantalla la siguiente pregunta:</p>
<pre><code class="bash">
 ¿Desea ver el informe de nuevo (presione S/N)? _

</code></pre>
<ul>
<li>Asumiendo se presiona <code>S</code>, hasta que no se presione <code>ENTER</code> <em>no pasan los datos ingresados del buffer al programa</em>
</li>
<li>Al programa llegan ambos caracteres: la tecla <code>S</code> y el <code>ENTER</code>
</li>
</ul>

</section>
<section>

<h2>Buffer intermedio</h2>

<ul>
<li>Este buffer puede ser molesto en entornos interactivos</li>
<li>
<code>getchar()</code> lee de a un carácter y si ingresa más de uno quedan esperando
en la cola de entrada</li>
<li>Este buffer es configurable manipulando atributos de la terminal

<ul>
<li>Más información en <strong>man termios</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de getchar y putchar: <code>cat</code>
</h2>
<pre><code class="c">#include &lt;stdio.h&gt;  

int main(void) 
{
  int c;

  printf("\nIngrese un caracter "); 
  c = getchar();

  while (c != EOF) {
    putchar(c);
    c=getchar();
  }

  return 0;
}
</code></pre>
<p><small>
<ul>
<li>
<strong>Notar que</strong>
  <ul>
  <li>
<code>int c </code> se debe a que <code>EOF</code> es -1. Este valor no puede mapearse al tipo char, entonces queda en <code>NULL</code>
</li>
  <li>
<code>getchar()</code> y <code>putchar()</code> trabajan caracter a caracter.
  </li>
</ul>
</li>
</ul>
</small></p>

</section>
<section>

<h3>Versión mejorada</h3>
<pre><code class="c">
#include &lt;stdio.h&gt;  

int main(void)
{
  int c;

  while ( (c=getchar()) !=EOF) {
    putchar(c);
  }

  return 0;
}

</code></pre>
</section>
<section>

<h2>Descarga de ejemplos</h2>

<ul>
<li><p><a href="images/ejemplos/03/01-getchar.c">Uso de getchar</a></p></li>
<li><p><a href="images/ejemplos/03/02-getchar-descarta-buffer.c">Descartando chars</a></p></li>
<li><p><a href="images/ejemplos/03/02-getchar-unbuffered.c">Evitando el buffer con getchar</a></p></li>
</ul>

</section>
<section>

<h2>Entrada y Salida con formato</h2>
<pre><code class="c">
int printf(const char *cadena_de_control, ...)

int scanf(const char *cadena_de_control, ...)

</code></pre>
<p><small class="fragment highlight-blue">
En las entradas y salidas con formato, se pueden agregar caracteres de conversión.
</small></p>

</section>
<section>

<h2>printf</h2>
<pre><code class="c">
  int printf(formato, arg1, arg2, ...)

</code></pre>
<ul>
<li>Formato es un string compuesto por dos tipos de objetos:

<ul>
<li>Caracteres que son copiados directamente en la salida</li>
<li>Especificaciones de conversión, cada uno de los cuales causa la conversión
e impresión de los siguientes argumentos sucesivo del printf</li>
</ul>
</li>
<li><em>Debe existir el mismo número de caracteres de formato que de argumentos</em></li>
<li>
<strong>Retorna la cantidad de caracteres escritos</strong> y -1 si se ha producido un error.</li>
</ul>

</section>
<section>

<h2>Un primer ejemplo</h2>
<pre><code class="c">
int dia = 6, a = 8;

float var_flotante = 2.52345;

char mes[]="abril";

printf("Estamos en la clase de C");

printf("Hoy es lunes %d de %s", dia, mes);

printf("Ejemplo var_flotante = %0.2f", var_flotante);

</code></pre>
</section>
<section>

<h2>Caracteres de conversión de printf</h2>

<p>Cada especificación de conversión comienza con un % y termina con un carácter de conversión. </p>

<p>Entre estos dos caracteres hay otros modificadores que <strong>deben especificarse en un orden determinado</strong></p>

<p>A continuación detallamos estos modificadores</p>

</section>
<section>

<h3>Modificadores de formato</h3>

<ul>
<li>Un # que convierte a formato alternativo</li>
<li>Un 0 para llenar el padding con ceros</li>
<li>Un signo - que especifica ajuste a izquierda;</li>
<li>Un número que especifica un ancho mínimo del campo (si es necesario se rellena con espacios en blanco para completar este valor);</li>
<li>Un punto que separa el ancho del campo de la precisión;</li>
<li>Otro número, la precisión, que indica el número de dígitos después del punto decimal (si es float) o el número mínimo de dígitos para un entero, o para strings la cantidad máxima de caracteres</li>
</ul>

<p><small class="fragment">
<a href="images/ejemplos/03/03-printf.c">Descargar ejemplo de uso de modificadores</a>
</small></p>

</section>
<section>

<h2>Los caracteres de conversión</h2>

<table>
<thead>
<tr>
<th>Char</th>
<th>Tipo</th>
<th>Se imprime como</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>d,i</code></td>
<td><code>int</code></td>
<td>Número decimal</td>
</tr>
<tr>
<td><code>o</code></td>
<td><code>int</code></td>
<td>Octal sin signo (sin el cero inicial</td>
</tr>
<tr>
<td><code>x,X</code></td>
<td><code>int</code></td>
<td>Hexadecimal</td>
</tr>
<tr>
<td><code>u</code></td>
<td><code>int</code></td>
<td>Decimal sin signo</td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>int</code></td>
<td>Caracter</td>
</tr>
<tr>
<td><code>s</code></td>
<td><code>char *</code></td>
<td>Cadena de caracters</td>
</tr>
<tr>
<td><code>f</code></td>
<td><code>float</code></td>
<td>Número flotante</td>
</tr>
</tbody>
</table>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="c">
#include&lt;stdio.h&gt;

int main(void)
{
  int i;

  printf("%8s %8s %8s\n", "^1", "^2", "^3");

  for (i=1; i&lt;6; i++) printf("%8d %8d %8d\n", i, i*i, i*i*i);

  return 0;
}

</code></pre>
<p><small>
<a href="images/ejemplos/03/04-printf-tabla.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>scanf</h2>

<p>Lee datos de <code>STDIN</code></p>
<pre><code class="c">
  int scanf(const char *cadena_ctrl, …);

  /* Usada generalmente de la siguiente forma */
  scanf(tipo, &amp;var)

</code></pre>
<ul>
<li>Donde:

<ul>
<li>
<strong>tipo:</strong> tipo de dato a almacenar</li>
<li>
<strong>Ampersand (&amp;):</strong> indica la dirección de memoria de la variable donde se almacenará el dato. Cuando se guardan cadenas de caracteres el &amp; se omite</li>
<li>
<strong>var:</strong> variable para almacenar el dato</li>
</ul>
</li>
</ul>

<p><small class="fragment highlight-red">
Retorna el número de datos a los cuales se les ha asignado un valor con éxito
</small></p>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(){

  int x, y, res;

  printf("\nIngrese dos valores enteros separados por -,"
         "luego presione enter:");

  res = scanf("%d-%d", &amp;x, &amp;y);

  printf("\nSe leyeron: \n\t1\t=&gt;\t%d\n\t2\t=&gt;\t%d\n"
         "El resultado del scanf fue: %d\n", x, y, res);

  return 0;
}
</code></pre>
<p><small>
<a href="images/ejemplos/03/05-scanf.c">Descargar ejemplo 05-scanf.c</a>
</small></p>

</section>
<section>

<h2>Buenas prácticas</h2>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(){
  int val;
  do {
    printf("\nIngrese un número entero (-1 termina, "
           "letras se descartan): ");
    while (scanf("%d", &amp;val) != 1) {
      fprintf(stderr, "Error. Intente nuevamente: ");
      getchar();
    }
    printf("Se leyó: %d", val);
  } while(val != -1);
  return 0;
}
</code></pre>
<p><small>
<a href="images/ejemplos/03/06-scanf-buen-uso.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Consideraciones de scanf</h2>

<ul>
<li>La cadena de control consta de 3 clases de caracteres:

<ul>
<li>Especificación de formato: van precedidos por % e indican el tipo de dato a leer. Tienen orden</li>
<li>Caracteres de espacio en blanco</li>
<li>Caracteres que no son espacios en blanco.</li>
</ul>
</li>
<li>Los espacios, las tabulaciones y los saltos de línea se usan como separadores de campo. Dependiendo de la indicación del formato, el  espacio en blanco se interpreta de diferente manera.</li>
</ul>

</section>
<section>

<h2>Consideraciones</h2>

<table>
<thead>
<tr>
<th>Ejemplo</th>
<th>Descripcion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scanf("%c%c%c", &amp;a, &amp;b, &amp;c);</code></td>
<td>Ingresando <strong>"x y"</strong> queda a con x, b con blanco y c con y</td>
</tr>
<tr>
<td><code>scanf("%s", str);</code></td>
<td>Ingresando "hola mundo" queda hola</td>
</tr>
</tbody>
</table>

<h3>¿Cómo leemos espacions con scanf?</h3>

<p><small class="fragment">
<a href="images/ejemplos/03/07-scanf-con-espacios.c">Descargar ejemplo</a>
</small></p>

</section>
</section>
<section>

<h1>Clase 4</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>El preprocesador

<ul>
<li>Introducción</li>
<li>Características</li>
<li>Directivas</li>
<li>Macros</li>
<li>Concatenación</li>
</ul>
</li>
</ul>

</section>
<section>

<h1>El preprocesador</h1>

</section>
<section>
<section>

<h2>Introducción</h2>

<p><img src="images/4-1-el-preprocesador.png" alt="El preprocesador"></p>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Es un elemento del lenguaje C muy utilizado, que permite dar una respuesta al principio
de modularización y compilación separada que promueve C</li>
<li>Las instrucciones normales no afectan al preprocesador, tiene comandos especiales</li>
<li>Ventajas

<ul>
<li>Los programas son más fáciles de desarrollar</li>
<li>Son más fáciles de leer</li>
<li>Son más fáciles de modificar</li>
<li>Y el código de C es más transportable entre diferentes arquitecturas de máquinas</li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h2>Características</h2>

<ul>
<li>Se ejecuta <strong>antes</strong> que la compilación.</li>
<li>Realiza modificaciones en el archivo fuente.

<ul>
<li>Inclusión de textos.</li>
<li>Sustituciones.</li>
<li>Eliminar partes del fuente.</li>
</ul>
</li>
<li>Trabaja únicamente sobre los fuentes</li>
<li><em>No tiene en cuenta ningún aspecto sintáctico ni semántico del lenguaje</em></li>
</ul>

</section>
<section>

<h2>Funcionamiento</h2>

<div style="width: 45%; float: left;">
<img src="images/4-2-el-preprocesador.png">
</div>

<div class="fragment" style="width: 45%; float: left;">
<img src="images/4-2-1-el-preprocesador.png">
</div>

</section>
</section>

<section>
<section>

<h2>Directivas</h2>

<ul>
<li>Una directiva es una palabra que interpreta el preprocesador</li>
<li>Comienzan con el símbolo <strong>#</strong> (numeral)</li>
<li>Están situadas a principio de línea</li>
<li>Si involucran más de una línea se incluye el carácter \ (barra invertida) al final de la línea,
indicando que la línea continua abajo</li>
<li>No se utiliza el carácter <strong>;</strong> (punto y coma) al final de la línea</li>
</ul>

</section>
<section>

<h2>Directivas</h2>
<pre><code class="c">#include
#define
#undef

#if 
#else 
#endif

#ifdef 
#ifndef 
#elif 
</code></pre>
</section>
<section>

<h2>#include</h2>

<ul>
<li>Incluye el contenido del archivo indicado</li>
<li>Puede usarse de las siguientes formas:</li>
</ul>
<pre><code class="c">#include "nombr"

#include &lt;nombre&gt;
</code></pre>
<h3>Ejemplo:</h3>
<pre><code class="c">#include &lt;stdio.h&gt;

#include "../parent_subdir/my_header.h"
</code></pre>
</section>
<section>

<h2>¿Cómo compilamos muchos archivos?</h2>
<pre><code class="bash">
gcc -o prog archi1.c archi2.c

</code></pre>
<h3>Las opciones</h3>

<ul>
<li>
<strong>-c:</strong> preprocesa y compila a código objeto</li>
<li>
<strong>-o archivo:</strong> nombre del binario definitivo</li>
<li>
<strong>-Wall:</strong> muestra todos las advertencias del compilador

<ul>
<li><strong><em>Las advertencias son errores</em></strong></li>
</ul>
</li>
<li>
<strong>-E:</strong> sólo realiza <strong>preprocesamiento</strong>
</li>
</ul>

</section>
<section>

<h2>#define</h2>
<pre><code class="c">
#define nombre textoReemplazo

</code></pre>
<ul>
<li>Sustituye <strong>todas</strong> las ocurrencias de <strong><em>nombre</em></strong> por <strong><em>textoReemplazo</em></strong>
</li>
<li>Permite definir <strong>constantes simbólicas</strong>
</li>
</ul>
<pre><code class="c">
#define MAX 100

</code></pre>
<p><small class="fragment highlight-blue">
En ejecución no ocupa un lugar en la memoria porque se reemplaza por una
constante
</small></p>

</section>
<section>

<h2>#define</h2>

<ul>
<li>El alcance es desde donde se lo declara hasta el final del archivo fuente

<ul>
<li>Si el define se hace en un archivo incluido, entonces su alcance se propaga al archivo que usa el <code>#include</code>
</li>
</ul>
</li>
<li>Las sustituciones se hacen por elementos y no por strings encerrados entre comillas (")</li>
<li>
<strong>No</strong> hay que escribir el símbolo igual (=)</li>
<li>En general, el nombre se escribe en mayúsculas para diferenciarlo de las variables.</li>
</ul>

</section>
<section>

<h2>Errores habituales</h2>
<pre><code class="c">
#define MAX =100

#define MIN 10;


if (x == MAX) /* if (x == =100) */

if (x == MIN) /* if (x == 10;) */

</code></pre>
</section>
<section>

<h2>Errores habituales</h2>
<pre><code class="c">
#define C A+B

D = C * C /* A+B * A+B */

</code></pre>
<div class="fragment">
<h3> La forma adecuada </h3>

<pre>
<code class="c">

#define C (A+B)

</code>
</pre>
</div>

</section>
<section>

<h2>#define</h2>

<p>También permite definir <strong>macros personalizadas</strong></p>
<pre><code class="c">
#define abs(x) ( (x) &gt; 0 ? (x) : -(x) )

z = abs(a - 3); /* z = ( (a-3) &gt; 0 ? (a-3) : -(a-3) ); */

</code></pre>
<div class="fragment">
<h3>¿Cuál es el error de usar...?</h3>

<pre>
<code class="c">

abs(a++);

</code>
</pre>

</div>

</section>
<section>

<h2>Para tener en cuenta</h2>
<pre><code class="c">
#define swap(x,y) {int temp=x; x=y; y=temp;}

...

if (a&gt;b)
  swap(a,b)
else

...

</code></pre>
<p><small class="fragment highlight-red">
<strong>¿Cuál sería un posible problema?</strong>
</small></p>

</section>
<section>

<h2>Otro ejemplo con #define</h2>
<pre><code class="c">#define DOS 2
#define Doble(x) (DOS*(x))
#define Cuadruple(x) (Doble(Doble(x)))

....

z=Cuadruple(A);

....

</code></pre>
<h3>Deslozado</h3>
<pre><code class="c">
z = (Doble(Doble(A)));
z = ((DOS*(Doble(A))));
z = ((DOS*((DOS*(A)))));
z = ((2*(DOS*(A))));
z = ((2*((2*(A)))));

</code></pre>
</section>
<section>

<h2>¿Cómo se comporta con recursión?</h2>

<ul>
<li>Se efectúan los reemplazos en orden de definición y cuando llega al último reemplazo
se corta el proceso</li>
<li>
<strong>No</strong> continua en loop.</li>
</ul>
<pre><code class="c">
#define X Y
#define Y Z
#define Z X

....

A=X;

....

/* 
A = Y;
A = Z;
A = X
*/
</code></pre>
</section>
<section>

<h2>Otro ejemplo recursivo</h2>
<pre><code class="c">#define sqrt(x) ( (x) &lt; 0 ? 0 : sqrt(x) )

sqrt(-1);

sqrt(4);

</code></pre>
<div class="fragment highlight-red">
¿Qué sucede?
</div>

</section>
<section>

<h2>Macros predefinidas</h2>

<ul>
<li>Se definen con dos guiones bajos <strong>__</strong>

<ul>
<li>
<code>__FILE__</code> Es una cadena de caracteres que contiene el nombre del archivo fuente</li>
<li>
<code>__LINE__</code> El número de línea actual</li>
<li>
<code>__DATE__</code> fecha de compilación</li>
<li>
<code>__TIME__</code> hora de la compilación</li>
<li>
<code>__STDC__</code> 1, si compila ANSI C</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>La stringificación</h2>

<h3>Operadores de Macros</h3>

<ul>
<li>
<code>#</code>: si <code>x</code> es un parámetro de una macro, <code>#x</code> es el
parámetro actual correspondiente representado como
una cadena de caracteres.</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="c">
#define comoString(x) #x

comoString(3)   /* "3"      */
comoString(a b) /* "a b"    */
comoString("3") /* "\"3\""  */

</code></pre>
</section>
<section>

<h2>La concatenación</h2>

<h3>Operadores de Macros</h3>

<ul>
<li>
<code>##</code>: Se aplica cuando se procesa la macro y se reemplazan los
parámetros formales por los actuales. Los dos elementos que rodean al
operador se combinan</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="c">
a + b##c /* a +  bc */

#define concatenar(a,b) a##b

...
char prueba[] = "Hola mundo";
printf("%s", concat(pru,eba));


</code></pre>
</section>
<section>

<h2>Macros o funciones</h2>

<p>Si por alguna razón sucede que existe una macro y una función con el mismo
nombre, resolvemos el conflicto usando paréntesis en las funciones:</p>
<pre><code class="c">#define cuadrado(x) (x)*(x)

double (cuadrado)(double x ){
  return x*x + 1;
}

int main() {
  printf("%.2f con macro\n", cuadrado(2.0));
  printf("%.2f con funcion\n", (cuadrado)(2.0));
  return 0;
}
</code></pre>
</section>
<section>

<h2>define vs const</h2>

<p>Asumiendo los siguientes casos</p>
<pre><code class="c">
const int MAX = 100 + 20;

#define MAX 100 + 20

</code></pre>
<p><small class="fragment highlight-red">
En el uso <strong>MAX * MAX</strong> no se obtiene el mismo resultado
</small></p>

</section>
<section>

<h2>undef</h2>

<ul>
<li>Permite dejar sin efecto un <code>define</code> previo</li>
</ul>
<pre><code class="c">
#define MAX 12

..

#undef MAX

..

#define MAX 11


</code></pre>
</section>
</section>

<section>
<section>

<h1>Condicionales</h1>

</section>
<section>

<h2>Compilación condicional</h2>

<ul>
<li><p>El preprocesador permite incorporar o eliminar sentencias
de un código fuente según la evaluación de una expresión.</p></li>
<li><p>Es posible consultar por defined</p></li>
</ul>

<h3>Directivas</h3>
<pre><code class="c">#if ­ #else ­ #ifdef ­ #ifndef ­ #elif ­ #endif
#if defined(MAX)
...
#endif
...
#ifdef MAX
...
#endif
</code></pre>
</section>
<section>

<h2>#if #endif</h2>
<pre><code class="c">
#if DEBUG
...
#endif

</code></pre>
<p><small>
<a href="images/ejemplos/04/04-if.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>¿Cuál es el resultado?</h2>
<pre><code class="c">#define ARG 0
#define GB 1
#define ESP 2
#define PAIS_ACTIVO ESP

#if PAIS_ACTIVO == ARG
char moneda[] = "pesos";
#elif PAIS_ACTIVO == GB
char moneda[] = "libras";
#else
char moneda[] = "euro";
#endif
</code></pre>
</section>
<section>

<h2>¿Cómo se usa en los .h?</h2>

<ul>
<li>Para evitar inclusiones recursivas se utiliza <code>#ifndef</code> </li>
</ul>
<pre><code class="c">#ifndef _HEADER
#define _HEADER

....

#ifndef MAX
#define MAX 100
#endif

...

#endif
</code></pre>
</section>
</section>

<section>
<section>

<h2>Opciones del gcc</h2>
<pre><code class="c">#include &lt;stdio.h&gt;

#ifdef LINUX

#define MENSAJE "Estamos en Linux"

#else

#define MENSAJE "NO estamos en Linux"

#endif

int main(void){
  printf(MENSAJE);
}
</code></pre>
<p>Podemos definir la macro fuera del fuente</p>
<pre><code class="bash">
gcc -o prog -DLINUX archi1.c

</code></pre>
</section>
</section>
<section>

<h1>Clase 5</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Punteros

<ul>
<li>Introducción</li>
<li>Operadores &amp; y *</li>
<li>Pasaje por referencia</li>
<li>Arreglos</li>
<li>Aritmética de punteros</li>
<li>Strings</li>
<li>Asignación dinámica</li>
<li>Arreglos de punteros</li>
</ul>
</li>
</ul>

</section>
<section>

<h1>Punteros</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Un puntero a un dato es la dirección del primer byte que forma parte del mismo.</li>
<li>Las variables de tipo puntero contienen la dirección de memoria de un dato.</li>
<li>Un puntero consta de dos partes:

<ul>
<li>La dirección apuntada</li>
<li>El contenido apuntado</li>
</ul>
</li>
</ul>

<p><strong>Es importante programarlos en forma correcta y adecuada para evitar
comportamientos inesperados</strong></p>

</section>
<section>
<section>

<h2>Operadores &amp; y *</h2>

<p>Para declarar un puntero:</p>
<pre><code class="c">
un_tipo * ptr; /* ptr es una variable de tipo puntero a un_tipo.
                  contiene la direccion de memoria de un dato de tipo
                  un_tipo */

</code></pre>
<h3>Ejemplos</h3>
<pre><code class="c">
int * var_int;        /* para punteros a enteros */

double * var_double;  /* para punteros a double */

char * var_char;      /* para punteros a char */

</code></pre>
</section>
<section>

<h2>Operadores &amp; y *</h2>

<p>Para desreferenciar una variable usamos <code>&amp;</code></p>
<pre><code class="c">int n=0;  /* n es una variable de tipo int */

int * p;  /* p es una variable de tipo puntero a un int,
             que contendrá la dirección de un int */

p = &amp;n;   /* Se asigna a p el valor de la dirección de n */

</code></pre>
<p>Para referenciar el contenido de un puntero usamos <code>*</code></p>

<ul>
<li>
<code>*p</code> es equivalente al nombre de la variable <code>n</code>
</li>
<li>
<code>*p = 33</code> es equivalente a <code>n = 33</code>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<p>Supongamos el siguiente extracto de código:</p>
<pre><code class="c">
  int x = 5, y = 7, ptr1 = &amp;x, ptr2 = &amp;y;

</code></pre>
<p>Analizar gráficamente qué sucede con:</p>

<ul>
<li><code>ptr1 = ptr2</code></li>
<li><code>*ptr1 = *ptr2</code></li>
</ul>

</section>
</section>

<section>
<section>

<h2>Pasaje por referencia</h2>

<p>Analizando el siguiente código</p>
<pre><code class="c">void cambiar(int a, int b){
  int aux;
  aux = a;
  a = b;
  b = aux;
}

int main (){
  int x = 10, y = 20;
  cambiar(x, y);
}
</code></pre>
<p><small class="fragment">
Recordar que en C <strong>no</strong> exite el pasaje por referencia. <br>
El código anterior <strong>no cambia nada</strong>
</small></p>

</section>
<section>

<h2>Pasaje por referencia</h2>

<p>Si recordamos el uso del <code>scanf</code>, vemos un ejemplo de cómo se simula el pasaje
por referencia</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(){
  int x; char mensaje[30];

  scanf("%d", &amp;x);

  scanf("%s", mensaje);

  return 0;
}
</code></pre>
<p><small style="color: red">
Pero.... ¿Mensaje no se precede con &amp;?
</small></p>

</section>
</section>

<section>
<section>

<h2>Arreglos</h2>

<ul>
<li>De los arreglos sabemos que:

<ul>
<li>Se definen como <code>un_tipo variable[TAM];</code>
</li>
<li>Se indexan de 0 (cero) a TAM - 1</li>
<li>La asignación de valores puede hacerse en el momento de la declaración</li>
</ul>
</li>
</ul>

<h3>Ejemplos</h3>
<pre><code class="c">int x[12];

int num[] = { 1, 2 };

char cadena_1[128] = "Hola Mundo";

char cadena_2[] = "Hola";
</code></pre>
</section>
<section>

<h2>Arreglos</h2>

<ul>
<li>El nombre del arreglo referencia a la dirección del elemento 0 del arreglo</li>
<li>El nombre del arreglo es una constante</li>
<li>Cuando se declara un arreglo se reservan un número específico de posiciones de
memoria para ese arreglo</li>
<li>Son elementos consecutivos en la memoria</li>
<li>C NO tiene control del índice</li>
</ul>

<p><small>
<a href="images/ejemplos/05/./01-show-array-ptr.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Arreglos como parámetro</h2>

<ul>
<li>Los arreglos se pasan como parámetro sin especificar la dimensión</li>
<li>Esto es porque el nombre de un arreglo representa la posición de memoria donde
se inicia</li>
<li>La dimensión del arreglo debe pasarse en otro parámetro para controlar acceder
al arreglo dentro de los límites del mismo</li>
</ul>
<pre><code class="c">
  int sum(int vec[], int dim);

</code></pre>
</section>
<section>

<h2>Un ejercicio</h2>

<ul>
<li>Implementar una función que reciba un arreglo de enteros y calcule:

<ul>
<li>La sumatoria</li>
<li>El mínimo</li>
<li>El máximo</li>
<li>El promedio</li>
</ul>
</li>
</ul>

<p>Y devuelva todos estos valores</p>

<p><small class="fragment">
<a href="images/ejemplos/05/02-min-max-avg.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h3>Arreglos multidimensionales</h3>

<p>Son arreglos de arreglos</p>
<pre><code class="c">int i, j, matrix[10][20];

for(i = 0; i &lt; 10; i++) {
  for(j = 0; j &lt; 20;j++) {
    matrix[i][j] = 0;
  }
}
</code></pre>
<p>Inicialización</p>
<pre><code class="c">
int matrix_2[3][4] = { { 1, 2, 3, 4 },
                       { 5, 6, 7, 8 },
                       { 9, 10, 11, 12 } };

</code></pre>
<p>O alternativamente, pero <strong>NO RECOMENDADO</strong></p>
<pre><code class="c">
int matrix_3[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

</code></pre>
</section>
<section>

<h2>Arreglos multidimensionales como parámetros</h2>
<pre><code class="c">
void sample(int matrix[][10], int row_size);

</code></pre>
</section>
<section>

<h2>Punteros y arreglos</h2>

<p>Existe una fuerte relación entre punteros y arreglos</p>

<p><strong>El nombre de un arreglo es una constante puntero</strong></p>
<pre><code class="c">
int my_array[] = {10, 20, 30, 40, 50};

printf("my_array[0] = %d", my_array[0]); /* Imprime: my_array[0] = 10 */

printf("*my_array = %d", *my_array);     /* Imprime: *my_array = 10 */

</code></pre>
<p><small class="fragment">
<strong>Todo lo que se logra con indexación de arreglos, se logra con punteros</strong>
</small></p>

</section>
<section>

<h2>En memoria, el arreglo se almacena</h2>
<pre><code class="c">
int my_array = { 1, 2 }

</code></pre>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Posición</th>
<th style="text-align: right">Contenido</th>
</tr>
</thead>
<tbody>
<tr>
<td>my_array</td>
<td>0xA000</td>
<td style="text-align: right">0XA101</td>
</tr>
<tr>
<td>my_array[0]</td>
<td>0xA101</td>
<td style="text-align: right">1</td>
</tr>
<tr>
<td>my_array[1]</td>
<td>0xA105</td>
<td style="text-align: right">2</td>
</tr>
</tbody>
</table>
<pre><code class="c">
my_array[0] == *my_array

my_array[1] == *(my_array + 1)

</code></pre>
</section>
<section>

<h2>Punteros y arreglos</h2>

<p>Cualquier expresión escrita como arreglo e índice es equivalente a una expresión
escrita como un puntero y un desplazamiento</p>
<pre><code class="c">int my_array[10], *ptr;

/*

  my_array[i] equivale a *(my_array +i)

  &amp;my_array[i] equivale a (my_array +i)

  ptr[i] equivale a *(ptr + i)

*/

</code></pre>
</section>
</section>

<section>
<section>

<h2>Aritmética de punteros</h2>

<ul>
<li>Si <code>p</code> y <code>q</code> apuntan a elementos del <strong>mismo arreglo</strong>, entonces es correcto utilizar
los operadores <strong>==</strong>, <strong>!=</strong>, <strong>&lt;</strong>, <strong>&gt;</strong>, <strong>&lt;=</strong>, <strong>&gt;=</strong>
</li>
<li>
<code>p &lt; q</code> es <em>verdadero</em> si <code>p</code> apunta a un elemento que está antes en el arreglo de lo 
que está el que apunta <code>q</code>
</li>
<li>Cualquier puntero se lo puede comparar con <code>0</code> (<strong>==</strong> o <strong>!=</strong>)</li>
<li>Se puede sumar o restar un entero a un puntero:

<ul>
<li><code>p + i;</code></li>
<li><code>p - i:</code></li>
</ul>
</li>
<li>Si <code>p</code> y <code>q</code> apuntan a elementos del mismo arreglo, entonces está permitido la resta
entre <code>p</code> y <code>q</code>
</li>
</ul>

</section>
<section>

<h2>No es posible</h2>

<ul>
<li>Sumar punteros</li>
<li>Multiplicar o dividir punteros</li>
<li>Enmascarar</li>
<li>Sumar un float o double a un puntero</li>
<li>Asignar o copiar un arreglo a otro arreglo</li>
</ul>
<pre><code class="c">
int array_a[] = {1, 2, 3, 4},
    array_b[] = {10, 20, 30, 40};

a = b;  /* NO ES POSIBLE */

a == b  /* Devuelve true si a y b hacen referencia a la misma
         * posición de memoria. No compara elementos 
         */

</code></pre>
</section>
</section>

<section>
<section>

<h2>Cadenas de caracteres o strings</h2>

<ul>
<li>El uso más habitual de los arreglos son los strings</li>
<li>Un string es un arreglo de caracteres terminada en nulo

<ul>
<li>Un nulo es un <code>0</code> (cero)</li>
</ul>
</li>
<li>El compilador completa este <code>0</code> (cero) automáticamente.</li>
</ul>
<pre><code class="c">
char cadena[11];

char cadena[]="Hola"; /* Constante string que equivale
                       * a {'H', 'o', 'l', 'a', '\0' }
                       */

</code></pre>
<ul>
<li>Las librerías <code>string.h</code> y <code>strings.h</code> contienen las funciones
habituales para la gestión de strings

<ul>
<li><code>man string</code></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Reinventando la rueda</h2>

<ul>
<li>A continuación veremos ejemplos de funciones de <code>string.h</code>

<ul>
<li><a href="images/ejemplos/05/03-my_strlen_v1.c"><code>my_strlen_v1</code></a></li>
<li><a href="images/ejemplos/05/04-my_strlen_v2.c"><code>my_strlen_v2</code></a></li>
<li><a href="images/ejemplos/05/05-my_strlen_v3.c"><code>my_strlen_v3</code></a></li>
<li><a href="images/ejemplos/05/06-my_strcpy.c"><code>my_strcpy</code></a></li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h2>Asignación dinámica de memoria</h2>

<ul>
<li>Mecanismo que permite alocar memoria durante la ejecución del programa</li>
<li>La memoria asignada se toma de la <strong>heap</strong>
</li>
<li>Disponemos de las siguientes funciones provistas por <code>stdlib.h</code>
</li>
</ul>
<pre><code class="c">
void *calloc(size_t nmemb, size_t size);

void *malloc(size_t size);

void *realloc(void *ptr, size_t size);

void free(void *ptr);

</code></pre>
<p><small class="fragment">
<a href="http://man7.org/linux/man-pages/man3/malloc.3.html"><code>man malloc</code></a>
</small></p>

</section>
<section>

<h2>Ejemplos</h2>
<pre><code class="c">
char * p = (char *) malloc(10 * sizeof(char));

int  * q = (int *) calloc(10, sizeof(int)),
     * dyn_array = NULL,
     i;

free(p);
free (q);

for(i=1; i &lt; 1000; i++) {
  dyn_array = realloc(dyn_array, i * sizeof(int));
}

free (dyn_array);
</code></pre>
<p><small>
<ul class="fragment">
 <li><a href="images/ejemplos/05/07-dynamic-allocation.c">Ejemplo arreglo dinamico v1</a></li>
 <li><a href="images/ejemplos/05/08-dynamic-allocation-realloc.c">Ejemplo arreglo dinamico v2</a></li>
</ul>
</small></p>

</section>
<section>

<h2>La precedencia es muy importante</h2>

<p>Si recordamos la tabla de precedencia de operadores, podemos ver que las
primeras líneas se enumeran así</p>

<ul>
<li><code>() [] -&gt;</code></li>
<li><code>! ~  ++ -- - (tipo) * &amp; sizeof</code></li>
<li><code>* / %</code></li>
<li><code>+ -</code></li>
<li><code>&lt;&lt; &gt;&gt;</code></li>
<li>
<code>Continúa ...</code> </li>
</ul>

<p><small>
<strong><em>La tabla va de mayor prioridad a menor prioridad</em></strong>
</small></p>

</section>
<section>

<h2>¿Qué es lo que estaría mal en el siguiente ejemplo?</h2>
<pre><code class="c">void some_function(** ptr) {
  ...
  *ptr[i] = some_var;
  ...
}
</code></pre>
<p><small>
<strong><em>Considerar la tabla de prioridades</em></strong>
</small></p>

<p><small class="fragment">
<a href="images/ejemplos/05/08-dynamic-allocation-realloc-ERROR.c">Ejemplo arreglo dinamico v2 con error</a>
</small></p>

</section>
<section>

<h2>Un error común</h2>

<ul>
<li><strong>No debe retornarse un arreglo definido como variable automática</strong></li>
<li>Puede retornarse un puntero o usar una variable <strong>static</strong>
</li>
</ul>

<p><small>
<ul class="fragment">
 <li><a href="images/ejemplos/05/09-return-array-error.c">Ejemplo error</a></li>
 <li><a href="images/ejemplos/05/09-return-array-error-SOLVED.c">Ejemplo solución del error</a></li>
</ul></small></p>

</section>
</section>

<section>
<section>

<h2>Arreglos de punteros</h2>

<p>Como las variables de tipo punteros son como cualquier otra,
entonces podemos almacenarlas en un arreglo</p>

<h3>Ejemplo</h3>

<ul>
<li>En este caso creamos un arreglo donde cada elemento es un puntero a char</li>
</ul>
<pre><code class="c">
char *lineas[5];    /* Arreglo de 5 punteros a char */

</code></pre>
<ul>
<li><p><code>lineas[i]</code> es un puntero a char</p></li>
<li><p><code>*lineas[i]</code> es el primer carácter de la línea i-ésima</p></li>
</ul>

</section>
<section>

<h2>Ejemplos de arreglos de punteros</h2>
<pre><code class="c">
char * palabras [ ] = {"break", "continue", "do", "if", "int"};

</code></pre>
<ul>
<li>
<code>palabras[0]</code> 

<ul>
<li>Al igual que <code>*palabras</code>
</li>
<li>Contiene <em>break</em>
</li>
</ul>
</li>
<li>
<code>palabras[1]</code> 

<ul>
<li>Al igual que <code>*(palabras +1)</code>
</li>
<li>Contiene <em>continue</em>
</li>
</ul>
</li>
<li>
<code>palabras[1][2]</code>

<ul>
<li>Al igual que <code>*(palabras [1] +2)</code>
</li>
<li>Al igual que <code>*(*(palabras +1)+2)</code>
</li>
<li>Contiene <em>n</em>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Un ejemplo</h2>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
{
  char *dias[]= { "lunes", "martes", "miercoles",
                  "jueves", "viernes", "sabado",
                  "domingo", };
  int i;
  for (i=0; i&lt;7; i++) printf("El dia %d es %s\n",i,dias[i]);

  return 0;
}
</code></pre>
<p><small>
<a href="images/ejemplos/05/10-read-words.c">Descargar ejemplo que lee, ordena e imprime
palabras</a>
</small></p>

</section>
<section>

<h2>Arreglos de punteros multidimensionales</h2>

<p>Analizar qué cantidad de espacio se necesita en cada caso:</p>
<pre><code class="c">
  int a[10][20];

  int *b[10];

</code></pre>
</section>
</section>

<section>
<section>

<h2>Argumentos al programa principal</h2>

<ul>
<li>La función <code>main</code> puede especificar dos parámetros</li>
<li>Generalmente a estos parámetros se los llama

<ul>
<li>
<strong>argc</strong>: de tipo entero</li>
<li>
<strong>argv</strong>: de tipo char * []</li>
</ul>
</li>
<li>Crear un programa y verificar el valor de argv[0]</li>
</ul>
<pre><code>
#include &lt;stdio.h&gt;

int main (int argc, char *argv[]){
  int i;
  for(i=0; i&lt;argc; i++) printf("%s\n", argv[i]);
  return argc;
}

</code></pre>
</section>
</section>
<section>

<h1>Clase 6</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Estructuras</li>
<li>Definición de tipos</li>
<li>Estructuras dinámicas</li>
<li>Uniones</li>
</ul>

</section>
<section>
<section>

<h2>Estructuras</h2>

</section>
<section>

<h2>Estructuras: Introducción</h2>

<ul>
<li>Permiten crear un tipo de datos propio.</li>
<li>Agrupan variables bajo un nombre</li>
<li>Permite mantener junta información relacionada</li>
<li>Suele llamarse tipo de dato agregado</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="c">struct etiqueta {
  tipo nombre_miembro_1;
  tipo nombre_miembro_2;
  tipo nombre_miembro_3;
}
</code></pre>
</section>
<section>

<h2>Variables e inicialización</h2>

<p>En el siguiente caso, se define la estructura y declaran dos variables en la
misma línea</p>

<p>Luego se definen otras variables y realiza una asignación</p>
<pre><code class="c">
struct t_student {

  int file_number;
  char name[256];

} student_1, student_2;

struct t_student student_3;
struct t_student student_4 = { 1234, "Juan Perez" };

student_2 = student_4;

</code></pre>
</section>
<section>

<h2>Representación en memoria</h2>

<ul>
<li>Cuando se declara una variable, el compilador dispone automáticamente de
suficiente memoria para almacenar todos sus miembros</li>
<li>Cada variable estructura contiene su propia copia de miembros de la
estructura.</li>
<li>Una estructura como la anteriormente definida se representa de la siguiente
forma en memoria</li>
</ul>
<pre><code>        +---------------------------------+-----------------+
        |           256 bytes name        | 4 bytes file_no |
        +---------------------------------+-----------------+
</code></pre>
<p><small>
El ejemplo es a modo ilustrativo dado que por cuestiones de alineación se
utilizan estrategias diferentes. <a href="https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86">Ver ejemplo de
alineación</a>
</small></p>

</section>
<section>

<h2>Variables sin nombre para el tipo</h2>

<p>Es posible definir estructuras sin <strong>nombre de tipo</strong>, especificando el nombre de la
variable</p>
<pre><code class="c">
struct {
  int file_number;
  char name[256];
} student_1, student_2;

</code></pre>
</section>
<section>

<h2>Acceso a los miembros</h2>

<p>El punto sirve para referenciar el miembro de una estructura</p>
<pre><code class="c">  student_1.file_number;
  student_2.name;

  scanf("%s",student_3.name);
  scanf("%d", &amp;student_3.file_number);
  printf("Student name %s (%d)",
          student_3.name,
          student_3.file_number);

</code></pre>
</section>
<section>

<h2>Estructuras anidadas</h2>
<pre><code class="c">
  struct t_address {
    char address[256];
    char city[256];
  };

  struct t_student {
    int file_number;
    char name[256];
    float average_note;
    struct t_address address;
  }

</code></pre>
</section>
<section>

<h2>Arreglos de estructuras</h2>

<ul>
<li>Las estructuras suelen incluirse en arreglos</li>
<li>Primero se define la estructura y luego el arreglo:</li>
</ul>
<pre><code class="c">  struct t_student student_list[100];
  ...
  for(i=0; i &lt; 100; i++) {
    printf("%d - %s",
            student_list[i].file_number,
            student_list[i].name);
  }

</code></pre>
</section>
<section>

<h2>Inicialización de estructuras</h2>
<pre><code class="c">
  struct t_month {

    char * name;
    unsigned int num_days;

  } month[] = {

    {"Ninguno", 0},
    {"Enero", 31},
    {"Febrero", 28},
     .....
    {"Noviembre", 30},
    {"Diciembre", 31}
  };

</code></pre>
</section>
<section>

<h2>Estructuras y punteros</h2>

<p>Los punteros a estructuras se utilizan como los punteros a cualquier otra
variable.</p>
<pre><code class="c">struct t_student * ptr_student;

ptr_student = &amp; student_1;

printf("%d - %s", (*ptr_student).file_number, (*ptr_student).name);

/* O equivalentemente */

printf("%d - %s", ptr_student-&gt;file_number, ptr_student-&gt;name);

</code></pre>
</section>
<section>

<h2>Estructuras con miembros dinámicos vs estáticos</h2>

<p>Asumiendo los siguientes tipos de datos</p>
<pre><code class="c">struct  t_static_student {
char name[256];
float average_note;
int file_number;
} student_1, student_2;

struct t_dinamyc_student {
char *name;
float average_note;
int file_number;
} d_student_1, d_student_2;
</code></pre>
</section>
<section>

<h2>¿Qué sucede en cada caso?</h2>
<pre><code class="c">
strcpy(student_1.name, "Juan");
student_1.average_note = 9.5;
student_1.file_number = 100;
student_2 = student_1

d_student_1.name = malloc(sizeof(char)*256);
strcpy(d_student_1.name, "Juan");
d_student_1.average_note = 9.5;
d_student_1.file_number = 100;
d_student_2 = d_student_1;

</code></pre>
<p><small>
Analice qué sucede si modificamos <code>student2.name</code> y <code>d_student_2.name</code>
</small></p>

</section>
<section>

<h2>Del ejemplo anterior surge algo raro</h2>

<ul>
<li>Sabemos que no es posible asignar dos arreglos</li>
<li>Pero entonces en el ejemplo anterior, algo sucede cuando asignamos <code>student2 =
student1</code>
</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;

int main()
{
#ifdef ARR
  char a[10],b[10] = {'a','b',0};
  a = b;
  printf("b: %s\na: %s\n",b,a);
#else
  struct { char arr[10];} a,b = { {'a', 'b', 0} };
  a = b;
  printf("b: %s\na: %s\n",b.arr,a.arr);
#endif

  return 0;
}
</code></pre>
<p><small>
<a href="images/ejemplos/06/01-show-array-ptr.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Pasaje de estructuras como argumentos</h2>

<p>Asumiendo la siguiente estructura</p>
<pre><code class="c">struct t_example { char x;  int y;  float z;  char s[10];} sample;
</code></pre>
<p>Las siguientes llamadas a función son válidas:</p>
<pre><code class="c">func1(sample.x);    /* pasa el valor carácter de x */
func2(sample.y);    /* pasa el valor entero de y */
func3(&amp;sample.z);   /* pasa la dirección de z */
func4(sample.s);    /* pasa la dirección del string s */
func5(sample.s[2]); /* pasa el valor del carácter s[2] */
func6(e1);          /* pasa la estructura completa por valor */
func7(&amp;e1);         /* pasa la estructura completa por ref */
</code></pre>
</section>
</section>
<section>

<h1>Definición de tipos</h1>

</section>
<section>

<h2>Typedef</h2>

<ul>
<li>Permite definir tipos de datos a partir de tipos de datos existentes</li>
<li>
<code>typedef</code> <strong>no crea un nuevo tipo</strong> sino que crea un sinónimo para uno ya existente</li>
</ul>
<pre><code class="c">  typedef previous_type defined_type;
</code></pre>
<h3>Ejemplo</h3>
<pre><code>typedef int t_age; 

typedef struct {
          int file_number;
          char name[256];
        } t_student;

t_age age;
t_student student;
</code></pre>
</section>
<section>
<section>

<h2>Estructuras dinámicas</h2>

</section>
<section>

<h2>Estructuras dinámicas</h2>

<p>Son estructuras que se definen recursivamente
Se las utiliza para definir listas, árboles y grafos</p>
<pre><code class="c">struct t_node {
  t_data data;
  struct t_node *node;
}

typedef struct t_node * t_list;
</code></pre>
</section>
<section>

<h2>Implementando una lista</h2>

<ul>
<li>¿Cuáles serían las funciones necesarias para manejar la lista?

<ul>
<li>Crear</li>
<li>Buscar un elemento</li>
<li>Determinar si está vacía</li>
<li>Insertar elemento</li>
<li>Eliminar elemento: <em>elimina la primero ocurrencia que encuentre</em>
</li>
<li>Destruir lista</li>
<li>Operaciones para recorrer la lista</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Prototipos de la lista</h2>
<pre><code class="c">void    list_create(???);

short   list_find(???, t_data);

short   list_is_empty(???);

t_data  list_add(???, t_data);

t_data  list_delete(???, tdata);

void    list_destroy(???);

</code></pre>
</section>
<section>

<h2>Prototipos de la lista</h2>
<pre><code class="c">void    list_create(t_list *);

short   list_find(t_list, t_data);

short   list_is_empty(t_list);

t_data  list_add(t_list *, t_data);

t_data  list_delete(t_list *, tdata);

void    list_destroy(t_list *);

</code></pre>
</section>
<section>

<h2>Recorriendo la lista</h2>

<ul>
<li>Los tipos de datos, suelen implementar funciones asociadas que permiten recorrer las
estructuras sin revelar cómo fueron implementadas para simplificar su uso</li>
<li>Siguiendo este patrón, crearemos lo que llamaremos iteradores

<ul>
<li>Un iterador conocerá la lista que recorre</li>
<li>Podrán existir diferentes iteradores para una misma lista, cada uno podrá
estar en una posición diferente de la misma lista.</li>
<li>Los iteradores conocen la forma en que se implementa la lista para poder así
recorrerla</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Prototipo de un iterador</h2>

<p>El prototipo de un iterador sería:</p>
<pre><code class="c">t_list_iterator list_iterador_create(t_list );

void list_iterator_next(t_list_iterator *);

t_data list_iterator_data(t_list_iterator );

short list_iterator_end(t_list_iterator);
</code></pre>
<h3>Ejemplo de uso</h3>
<pre><code class="c">i = list_iterador_create(list); 

while(! list_iterator_end(i)) {

  t_data aux = list_iterator_data(i);
  ...
  list_iterator_next( &amp;i);
}
</code></pre>
<p><small>
<strong>Podría usarse un for en vez de un while</strong>
</small></p>

</section>
<section>

<h2>Implementaciones</h2>

<ul>
<li><a href="images/ejemplos/06/02-list-linked-nodes.zip">Ver ejemplo de lista como nodos enlazados</a></li>
<li><a href="images/ejemplos/06/03-list-array.zip">Ver ejemplo de lista implementada con arreglos</a></li>
<li><a href="images/ejemplos/06/04-bin-tree.zip">Ver ejemplo de árbol binario</a></li>
</ul>

</section>
</section>

<section>
<section>

<h2>Uniones</h2>

</section>
<section>

<h2>Uniones</h2>

<p>Son variables que pueden tener distinto tipo en momentos diferentes de la
ejecución de un programa</p>
<pre><code class="c">
union {

  int x;

  float y;

  char z[256];

} my_var;

</code></pre>
</section>
<section>

<h2>Uso de union</h2>

<ul>
<li>Se utilizan como las estructuras</li>
<li>La inicialización puede realizarse sólo con el primer miembro</li>
</ul>
<pre><code class="c">union {
  int x;
  float y;
  char z[256];
} my_var = { 10 };
</code></pre>
</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="c">struct shape {
     int type;
     double area;
     union {
       double side;
       double ratio;
       struct {
         double height;
         double width;
       } rectangle;
      } dimension;
  } my_shape;
</code></pre>
</section>
</section>
<section>

<h1>Clase 7</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Tipos de variables</li>
<li>El modificador <code>extern</code>
</li>
<li>El modificador <code>static</code>
</li>
<li>El modificador <code>register</code>
</li>
</ul>

</section>
<section>
<section>

<h2>Tipos de variables</h2>

</section>
<section>

<h2>Alcance y tiempo de vida de variables</h2>

<ul>
<li><p><strong>Alcance:</strong> porción del programa donde una variable puede referenciarse por su nombre. En C depende de cómo fue declarada y si se le ha aplicado algún <em>modificador</em></p></li>
<li><p><strong>Tiempo de vida:</strong> tiempo durante el cual una variable tiene reservada memoria</p></li>
</ul>

</section>
</section>

<section>
<section>

<h2>Variables externas</h2>

<ul>
<li>Las variables pueden definirse:

<ul>
<li>Después de la llave de apertura de un bloque</li>
<li>Antes del nombre de una función</li>
</ul>
</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;

int i = 0;
int main() {
  float p = 9.0;

  printf("%d %f\n", i, p)
  return 0;
}

float z = 7.5;
void print_something(){
  int j= 5;

  printf("%d %f %d\n", i, z, j)
}
</code></pre>
</section>
<section>

<h2>Variables externas</h2>

<p>El alcance abarca desde la definición hasta el final del archivo</p>
<pre><code class="c"> +----- int var_1;
 |      void function_1(int a ){
 |      int aux;
 |      ...
 |      }
 |
 |  +-- int var2_;
 |  |   void function_2(void ){
 |  |    ..
 |  |   }.
 |  |
 |  |  +-int var3_;
 |  |  | ...
 |  |  |
 V  V  V
</code></pre>
<p><small class="fragment">
 <strong>¿Cómo se las puede referenciar fuera de ese alcance?</strong>
</small></p>

</section>
<section>

<h2>El modificador extern</h2>

<p>Referencia una variable que no está dentro del archivo fuente o se hace
referencia antes de su definición</p>
<pre><code class="c">int var_1;
void function_1(){
  extern int var_3;
  ...
}
int var_2;
void function_2(){
  ...
}
int var_3;  
</code></pre>
<ul>
<li>Las variables <code>extern</code> cumplen que:

<ul>
<li>Se inicializan <strong>solo</strong> en su definición</li>
<li>Por defecto se inicializan en 0</li>
</ul>
</li>
</ul>

<p><small>
<a href="images/ejemplos/07/01-extern.zip">Descargar ejemplo</a>
</small></p>

</section>
</section>

<section>
<section>

<h2>Variables estáticas</h2>

</section>
<section>

<h2>Variables estáticas</h2>

<ul>
<li>Una variable <strong>estática interna</strong> proporciona almacenamiento privado y
permanente dentro de la función</li>
<li>Una variable <strong>estática externa</strong> limita su alcance al archivo fuente
donde está definida

<ul>
<li>Aplica también a funciones</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Variables estáticas</h2>
<pre><code class="c">#include &lt;stdio.h&gt;

int cuento() {
  static int x;
  return x++;
}

int main() {
int i;
  for(i=0 ; i&lt;10 ; i++) printf("%d\n", cuento());
  return 0;
}
</code></pre>
<ul>
<li>El valor de <code>x</code> se mantiene de llamada en llamada</li>
<li>Se inicializan sólo la primera vez que entra al bloque</li>
<li>Las variables estáticas se inicializan en 0 por defecto</li>
</ul>

<p><small>
<a href="images/ejemplos/07/02-static.c">Descargar ejemplo</a>
</small></p>

</section>
</section>

<section>
<section>

<h2>Variables Register</h2>

</section>
<section>

<h2>Variables Register</h2>

<ul>
<li>Si es posible estas variables estarán alocadas en los registros del
procesador</li>
<li>Se utilizan en variables que se van a utilizar con mucha frecuencia</li>
<li>Es una <em>sugerencia</em> al compilador</li>
<li>Tienen valores iniciales indefinidos</li>
</ul>
<pre><code class="c">  void f(register unsigned m){
    register int i;
    ...
  }
</code></pre>
</section>
</section>
<section>

<h1>Clase 8</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Archivos</li>
</ul>

</section>
<section>
<section>

<h2>Archivos</h2>

</section>
<section>

<h2>Archivos</h2>

<ul>
<li>En C, un archivo puede ser cualquier cosa: <em>desde un archivo en disco hasta una impresora</em>
</li>
<li>C provee una interfaz consistente e independiente del dispositivo al que se
está accediendo</li>
</ul>

<h3>Se representan internamente como</h3>

<ul>
<li>
<strong>streams (o flujo, secuencia) de datos:</strong>

<ul>
<li>Utiliza el tipo <code>FILE *</code> definido en <code>stdio.h</code>
</li>
<li>Se definen: <code>FILE *fp;</code>
</li>
</ul>
</li>
<li>
<strong>File descriptors de bajo nivel:</strong>

<ul>
<li>Son enteros</li>
</ul>
</li>
</ul>

<p><em>Ambas representaciones proveen funciones análogas</em></p>

</section>
<section>

<h2>Operaciones sobre archivos</h2>

<ul>
<li>Para operar con un archivo es necesario

<ul>
<li>
<strong>Abrirlo:</strong> conectando con una fuente de datos (datos en disco o
periféricos)</li>
<li>
<strong>Cerrarlo:</strong> al finalizar la transferencia</li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h2>Operaciones con streams</h2>

</section>
<section>

<h2>Abrir un stream</h2>

<ul>
<li>Se inicializa o abre un stream a través de <code>fopen</code>
</li>
<li>Retorna <code>NULL</code> si hay algún error</li>
</ul>
<pre><code class="c">
  fp = fopen(name, mode)

</code></pre>
<ul>
<li>Donde <code>mode</code> puede ser: r, w, a, r+, w+, a</li>
</ul>

</section>
<section>

<h2>Modos de fopen</h2>

<ul>
<li>
<code>r</code>: solo lectura al inicio</li>
<li>
<code>w</code>: trunca o crea un archivo. Se posiciona al principio</li>
<li>
<code>a</code>: abre un archivo para añadir datos o lo crea si no existe. Se posiciona al final</li>
<li>
<code>r+</code>: abre como lectura y escritura. Se posiciona al principio</li>
<li>
<code>w+</code>: abre como lectura y escritura, truncando el archivo si existe o
creandolo si no existe. Se posiciona al principio</li>
<li>
<code>a+</code>: abre como lectura y escritura o lo crea si no existe. Se posiciona al final de archivo</li>
</ul>

<p><small>
En todos los casos puede agregarse una <code>b</code> al final, pero se ignora en los
sistemas POSIX. En Linux no tiene sentido, pero se aconseja su uso cuando se
debe intercambiar datos con sistemas no UNIX
</small></p>

</section>
<section>

<h2>Cerrando un stream</h2>

<p>Los streams se cierran utilizando <code>fclose</code></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
extern int errno;

int main(int argc, char *argv[]) {
  FILE *fp;
  if (argc==2) {
    if ((fp = fopen(argv[1], "r"))){
      printf("El arch. %s pudo abrirse\n", argv[1]);
      fclose(fp);
    }
    else printf("ERROR al abrir %s:=&gt; %s\n", argv[1], strerror(errno));
  }
  else printf("Debe enviar nombre de archivo como parametro\n");
  return 0;
}
</code></pre>
<p><small>
<a href="images/ejemplos/08/01-file.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Streams estándar</h2>

<ul>
<li>Existen los siguientes archivos que no es necesario abrir o cerrar

<ul>
<li>
<code>STDIN</code>: solo de lectura</li>
<li>
<code>STDERR</code>: solo de escritura</li>
<li>
<code>STDOUT</code>: solo de escritura</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Lecturas desde un stream</h2>
<pre><code class="c">// De a bytes:
int fgetc(FILE *)

// De a lineas:
char * fgets(char *dato, int tam, FILE *fp)

// Con formato:
int fscanf(FILE *f, const char * format, ...)

// De a bloques:
size_t fread(void *dato, size_t tam, size_t cant, FILE * f)
</code></pre>
</section>
<section>

<h2>Escrituras desde un stream</h2>
<pre><code class="c">// De a bytes:
int fputc(int c, FILE *)

// De a lineas:
int fputs(const char *dato, FILE *fp)

// Con formato:
int fprintf(FILE *f, const char * format, ...)

// De a bloques:
size_t fwrite(void *dato, size_t tam, size_t cant, FILE * f)
</code></pre>
</section>
<section>

<h2>EOF</h2>

<ul>
<li>Para conocer si un archivo se ha recorrido y alcanzado el fin de archivo, se
utiliza la función <code>feof(FILE *)</code>
</li>
<li>El uso de esta función no es compatible con todas las operaciones de lectura
mencionadas, esto es, aunque sí se marque el EOF, esto no sucede como se
espera.</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="c">  i = 0;
  while (!feof(fp)) {
    fgets(buf, sizeof(buf), fp);
    printf ("Line %4d: %s", i, buf);
    i++;
  }
</code></pre>
<p><small class="fragment">
<span style="color: red">El código repite la última línea</span>
<br>
<a href="http://man7.org/linux/man-pages/man3/gets.3.html">man fgets</a>
<br>
<a href="images/ejemplos/08/02-feof-bad.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Solucionando el problema anterior</h2>

<p>Cuando se utiliza alguna función que manipule archivos, leer claramente el man para verificar
cuál es el valor de retorno. Entonces, en el caso de <code>fgets</code> su uso correcto
sería:</p>
<pre><code class="c">  i = 0;
  while (fgets(buf, sizeof(buf), fp) != NULL) {
    printf ("Linea %4d: %s", i, buf);
    i++;
  }
</code></pre>
<p><small class="fragment">
<a href="images/ejemplos/08/03-feof-fgets.c">Descargar ejemplo fgets y feof</a>
<br>
<a href="images/ejemplos/08/04-feof-fgetc.c">Descargar ejemplo fgetc y EOF</a>
</small></p>

</section>
<section>

<h2>Reusando lo aprendido con getc y putc</h2>

<p>En las primeras clases vimos cómo implementar el comando cat, ahora podemos
implementar el comando <strong>copy</strong> que copia dos archivos</p>
<pre><code class="c">  void copy(FILE *in , FILE *out) {
    int c;
    while ((c=getc(in))!=EOF) fputc(c, out);
  }
</code></pre>
<p><small class="fragment">
<a href="images/ejemplos/08/05-copy.c">Descargar ejemplo copy</a>
</small></p>

</section>
<section>

<h2>Uso de fscanf y fprintf</h2>

<p>Estas funciones trabajan con texto formateado, por lo que trabajarán con
archivos de texto y no binarios</p>
<pre><code class="c">void parse(FILE *in , FILE *out) {
  int count;
  float f1,f2,f3;
  while ((count = fscanf(in,"%f,%f,%f", &amp;f1, &amp;f2, &amp;f3)) ==3)
  {
    fprintf(out, "%.2f,%.2f,%.2f,%.2f\n", f1, f2, f3, f1+f2+f3);
  }
  if (!feof(in))
  {
    printf("Linea mal formada\n");
    myclose(in,out);
    exit(EXIT_FAILURE);
  }
}
</code></pre>
<p><small class="fragment">
<a href="images/ejemplos/08/06-format.c">Descargar ejemplo fscanf y fprintf</a> <em>Probar
con el <a href="images/ejemplos/08/06-sample.txt">ejemplo entregado</a></em>
</small></p>

</section>
<section>

<h2>Uso de fread y fwrite</h2>

<p>Estas funciones trabajan bajando la memoria tal cuál se almacena en ella, por
esto generalmente trabajarán con archivos binarios y no de texto</p>

<ul>
<li>Consideraciones

<ul>
<li>No todos los procesadores manejan la misma representación interna de tipos de
más de un byte</li>
<li>Acordar el tipo de endian (big o little) para utilizar en el intercambio</li>
<li>Algunas soluciones:

<ul>
<li><a href="http://man7.org/linux/man-pages/man3/gets.3.html">man 3 endian</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/htons.3.html">man 3 byteorder</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<p><small>
<a href="images/ejemplos/08/07-fread-fwrite.c">Descargar ejemplo fread y fwrite</a>
</small></p>

</section>
<section>

<h2>Uso de fseek y ftell</h2>

<p>Estas funciones permiten posicionarse en un archivo o determinar la posición
actual del cursor en un archivo respectivamente</p>
<pre><code class="c">
int fseek( FILE *flujo, long desplto, int origen);
  /* Donde origen puede ser:
   *    * SEEK_SET: desde el inicio
   *    * SEEK_CUR: desde la posición actual
   *    * SEEK_END: desde el final
   * fseek(fp, 0L, SEEK_CUR)
   * fseek(fp, 0L, SEEK_SET)
   * fseek(fp, 0L, SEEK_END)
   */

long ftell( FILE *flujo);

</code></pre>
<p><small>
<a href="images/ejemplos/08/08-tail.c">Descargar ejemplo tail</a>
</small></p>

</section>
</section>

<section>
<section>

<h2>Operaciones con file descriptors</h2>

<p>Operando con funciones de bajo nivel</p>

</section>
<section>

<h2>Funciones de bajo nivel</h2>

<ul>
<li>En vez de streams utilizan file descriptors

<ul>
<li>Los file descriptors son enteros</li>
<li>Las funciones de bajo nivel proveen la misma funcionalidad que las de streams
pero además otras funciones más específicas que no tienen sentido en streams</li>
<li>Existe una equivalencia entre file descriptors y streams</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Los archivos estandar</h2>

<ul>
<li>Los archivos estandar se definen en <code>unistd.h</code>

<ul>
<li>
<code>int STDIN_FILENO</code>

<ul>
<li> <em>valor cero</em>
</li>
</ul>
</li>
<li>
<code>int STDOUT_FILENO</code>

<ul>
<li><em>valor uno</em></li>
</ul>
</li>
<li>
<code>int STDERR_FILENO</code>

<ul>
<li><em>valor dos</em></li>
</ul>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Abriendo y cerrando archivos</h2>

<p>Las funciones de apertura y cierre son:</p>
<pre><code class="c">  int open(const char * nom, int flags, mode_t mode);
  int close(int fd)
</code></pre>
<p><small>
<a href="http://man7.org/linux/man-pages/man2/open.2.html">man 2 open</a>
<br>
<a href="http://man7.org/linux/man-pages/man2/close.2.html">man 2 close</a>
</small></p>

<h3>Equivalencias con STREAMS</h3>
<pre><code class="c">FILE * fdopen(int fd, const char * tipo);
int fileno(FILE * f);
</code></pre>
<p><small>
<a href="http://linux.die.net/man/3/fdopen">man 3 fdopen</a>
<br>
<a href="http://linux.die.net/man/3/fileno">man 3 fileno</a>
</small></p>

</section>
<section>

<h2>Uso de read y write</h2>
<pre><code class="c">ssize_t read(int fd, void * dato, size_t tam);

ssize_t write(int fd, const void * dato, size_t tam);
</code></pre>
<p><small>
<a href="http://man7.org/linux/man-pages/man2/read.2.html">man 2 read</a>
<br>
<a href="http://man7.org/linux/man-pages/man2/write.2.html">man 2 write</a>
</small></p>

</section>
</section>
<section>

<h1>Clase 9</h1>

</section>
<section>

<h2>Temario</h2>

<ul>
<li>Punteros a funciones</li>
<li>Punteros a void</li>
<li>Argumentos variables</li>
</ul>

</section>
<section>
<section>

<h2>Punteros a funciones</h2>

</section>
<section>

<h2>Punteros a funciones</h2>

<ul>
<li>Es uno de los recursos que mayor flexibilidad le otorgan al lenguaje</li>
<li>Las funciones tienen una ubicación física o dirección que corresponde al segmento de
código donde comienza la función</li>
<li>Es como un <em>alias</em> de la función

<ul>
<li><em>Una vez que un puntero apunta a una función se puede invocar a la función a través 
del puntero</em></li>
</ul>
</li>
<li>En general se utilizan para parametrizarlas funciones como argumentos de otras</li>
<li>Son punteros a código y no a datos

<ul>
<li><em>La dirección de la función se obtiene con el nombre de la misma</em></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Punteros a funciones</h2>
<pre><code class="c">
type (* function_name) [(args)]

</code></pre>
<ul>
<li>Los punteros a funciones pueden:

<ul>
<li>Pasar como argumentos</li>
<li>Ser retornados por una función</li>
<li>Ser miembros de un arreglo</li>
<li>Declararse con typedef</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="c">int comprobar(const char *a, const char *b,
              int (*cmp) (const char *, const char *)) {
  return cmp(a,b);
}
</code></pre>
<p><small>
<a href="images/ejemplos/09/01-ptr-function.c">Descargar ejemplo completo</a>
</small></p>

</section>
<section>

<h2>Typedef y punteros a funciones</h2>
<pre><code class="c">typedef double (*ptr_function)(char *);

/* Donde:
 *    * double es el tipo de retorno de la función
 *    * La función recibe un puntero a char
 *    * El nombre del tipo es ptr_function
 */

ptr_function p_func = xxx;
double test = p_func("2.13");
</code></pre>
<p><small>
<a href="images/ejemplos/09/02-ptr-function-typedef.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Arreglos de punteros a funciones</h2>

<p>Podemos simplemente definir arreglos de tipo punteros a función:</p>
<pre><code class="c">float (*operations[])(float, float) = { sum, minus, ... }
</code></pre>
<p>o usar <code>typedef</code> para simplificar la lectura:</p>
<pre><code class="c">typedef float (*float_operation_t) (float, float);

float_operation_t operations[] = { sum, minus, ...}
</code></pre>
<p><small>
<a href="images/ejemplos/09/03-ptr-function-arr.c">Descargar ejemplo sin typedef</a>
<br>
<a href="images/ejemplos/09/04-ptr-function-arr.c">Descargar ejemplo con typedef</a>
</small></p>

</section>
<section>

<h2>¿Es necesario usar &amp; con punteros a función?</h2>

<p>El estandar dice:</p>

<p><em>El valor a la izquierda (lvalue) de un tipo de función T será convertido a un <strong>puntero a TC</strong></em></p>
<pre><code class="c">void foo();
void bar(void (*func_ptr());

foo(bar);
foo(&amp;bar); /* equivalente al llamado anterior */
</code></pre>
</section>
<section>

<h2>Uso de qsort</h2>

<ul>
<li>La librería <code>stdlib</code> incluye la implementación del algoritmo de ordenamiento
<a href="https://es.wikipedia.org/wiki/Quicksort">Quick Sort</a>

<ul>
<li>Ordena cualquier arreglo, siempre que se especifique la forma en que se
comparan dos elementos de ese arreglo</li>
<li>Para ello la función recibe entre sus argumentos, la función de comparación</li>
</ul>
</li>
</ul>
<pre><code class="c">#include &lt;stdlib.h&gt;

void qsort(void *base, size_t nmemb, size_t size,
          int (*compar)(const void *, const void *));

</code></pre>
<p><small>
<a href="images/ejemplos/09/05-qsort.c">Descargar ejemplo</a>
</small></p>

</section>
</section>

<section>
<section>

<h2>Punteros genéricos</h2>

</section>
<section>

<h2>Pensemos cuándo usarlos...</h2>

<p>Desarrollar un algoritmo de manejo de lista o árbol genérico.
Por genérico, entendemos que el mismo algoritmo sea independiente del dato que
almacene</p>
<pre><code class="c">typedef struct node {
  void * data;
  struct node * left;
  struct node * right;
} * t_node;
</code></pre>
</section>
<section>

<h2>Punteros genéricos</h2>

<ul>
<li>Un puntero genérico o puntero a <code>void</code> es un puntero que puede apuntar a cualquier
tipo de dato.</li>
<li>Para que un puntero a <code>void</code> pueda ser desreferenciado debe <strong>castearse</strong> antes de
ser utilizado.</li>
</ul>
<pre><code class="c">
int main() {
  int var1 = 1;
  double var2 = 1.0;
  void* vptr ;

  vptr = &amp;var1;
  *(int *) vptr = 2;
  vptr = &amp;var2;
  *(float *) vptr = 4.0;
}

</code></pre>
</section>
<section>

<h2>¿Cómo sería el arbol genérico?</h2>

<p>En la clase 6, vimos una implementación de un árbol binario de búsqueda
implementado con enteros. <a href="images/ejemplos/06/04-bin-tree.zip">Descargar ejemplo</a></p>

<ul>
<li>La implementación genérica del árbol ahora nos permite:

<ul>
<li>Insertar de forma ordenada tipos difrentes</li>
<li>Recorrer el árbol en (in|pre|post)order haciendo lo que necesitemos</li>
</ul>
</li>
</ul>

<p><a href="images/ejemplos/09/06-generic-tree.zip">Descargar ejemplo de árbol binario genérico</a></p>

</section>
</section>

<section>
<section>

<h2>Lista de argumentos variable</h2>

</section>
<section>

<h2>Lista de argumentos variable</h2>

<p>Analizando <code>printf</code> vemos que podemos usarla de cualquiera de las siguientes
formas:</p>
<pre><code class="c">  printf("Hola Mundo");

  printf("Hola %s", "Mundo");

  printf("%s %s", "Hola", "Mundo");
</code></pre>
<ul>
<li>Observando detalladamente, sabemos que:

<ul>
<li>Un parámetro de los anteriores es <strong>obligatorio</strong>: <em>el string</em>
</li>
<li>En ese mismo argumento, se define con el formato, cuántos argumentos se
recibirán luego</li>
</ul>
</li>
<li>El prototipo es</li>
</ul>
<pre><code class="c">  int printf(const char * format, ...);
</code></pre>
</section>
<section>

<h2>Uso de argumentos variables</h2>

<ul>
<li>El soporte lo da la librería <code>stdagr.h</code>
</li>
<li>El ejemplo más común: <code>printf</code>
</li>
<li>Siempre hay al menos un argumento fijo</li>
<li>Encabezado general de una función con argumentos variables:</li>
</ul>
<pre><code class="c">
  int my_variable_args(arg1, arg2, argN, ...);

</code></pre>
</section>
<section>

<h2>¿Qué provee stdarg?</h2>

<ul>
<li>Disponemos de las siguientes macros:

<ul>
<li><code>va_start</code></li>
<li><code>va_arg</code></li>
<li><code>va_end</code></li>
</ul>
</li>
<li>Además se define el tipo <code>va_list</code> que permite declarar una variable que itere
sobre cada argumento.</li>
</ul>
<pre><code class="c">  void va_start(va_list ptr, last_arg);
  type va_arg(va_list ptr, type);
  void va_copy(va_list target, va_list source);
  void va_end(va_list ptr);
</code></pre>
</section>
<section>

<h2>¿Cómo usar stdarg?</h2>

<ul>
<li>La función que desee implementar argumentos variables debe tener al menos un
parámetro previo a la lista variable de argumentos, denominado <strong>last_arg</strong>
</li>
<li>
<strong>last_arg</strong> se lo utiliza como segundo argumento en <code>va_start</code>
</li>
<li>
<code>va_start</code> inicializa la lista para acceder a cualquier argumento variable</li>
<li>
<code>va_arg</code> se utiliza luego para tomar los argumentos, siendo <strong>type</strong> el tipo del
siguiente argumento</li>
<li>Una vez leídos todos los argumentos se llama a <code>va_end</code> para restaurar la pila</li>
</ul>

<p><small>
<a href="images/ejemplos/09/07-stdarg.c">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Variantes de printf</h2>

<p>La familia de funciones que se ofrecen por <code>stdio</code> considera:</p>
<pre><code class="c"> int vprintf(const char *format, va_list ap);
 int vfprintf(FILE *stream, const char *format, va_list ap);
 int vsprintf(char *str, const char *format, va_list ap);
 int vsnprintf(char *str, size_t size, const char *format, va_list ap);
</code></pre>
<p><small>
<a href="images/ejemplos/09/08-vprintf.c">Descargar ejemplo</a>
</small></p>

</section>
</section>

  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  (function() {
  function extend( a, b ) {
    for(var i in b) {
      a[i] = b[i];
    }
  }
  var baseOptions = {
    transition: 'default',

    dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
    ]
  };
  var configOptions = {"controls":true,"progress":true,"history":true,"center":true}
  var initializeOptions = {};
  extend(initializeOptions, baseOptions);
  extend(initializeOptions, configOptions);
  Reveal.initialize(initializeOptions);
})();

</script>

  </body>
</html>
